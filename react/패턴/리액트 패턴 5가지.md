> 해당 글은  [5 Advanced React Patterns](https://javascript.plainenglish.io/5-advanced-react-patterns-a6b7624267a6) 을 참고했습니다.

 

우리는 개발을 하면서 컴포넌트를 어떻게 개발을 해야할지 고민에 빠지는 경우가 있습니다.

대부분 어떠한 고민이냐면

- 어떻게 하면 컴포넌트를 **재사용** 가능하게 만들 수 있을까
- 어떻게 하면 컴포넌트를 **간단하게 사용**할 수 있게 만들 수 있을까
- 어떻게 하면 컴포넌트를 **확장 가능하게** 만들 수 있을까



이에 많은 개발자들은 여러 패턴을 만들기 시작했고 해당 문서에서는 5가지의 다른 패턴을 알아보겠습니다.

5개의 패턴으로 아래의 차이점에 대해 알아볼 것 입니다.

1. Counter 예제를 통한 실제 코드
2. 패턴의 장단점
3. 두 개의 기준을 가지고 비교
   1. Inversion of Control(IoC): 컴포넌트를 사용하는 유저에게 주어지는 유연성(flexibility)와 제어(control)의 정도
   2. Implementation complexity: 유저와 개발자 모두에 대해 그 패턴을 사용하는 난이도.
4. 해당 패턴을 사용한 라이브러리





# 1. Compound Components Pattern

이 패턴은 불필요한 [prop drilling](https://slog.website/post/13) 없게 컴포넌트를 만들 수 있게 도와줍니다.

좀 더 단독적이고 관심사를 분리하고 싶으면 해당 패턴을 추천합니다.

```react
import React from "react";
import { Counter } from "./Counter";

function Usage() {
  const handleChangeCounter = (count) => {
    console.log("count", count);
  };

  return (
    <Counter onChange={handleChangeCounter}>
      <Counter.Decrement icon="minus" />
      <Counter.Label>Counter</Counter.Label>
      <Counter.Count max={10} />
      <Counter.Increment icon="plus" />
    </Counter>
  );
}

export { Usage };
```

[Github 코드](https://github.com/alexis-regnaud/advanced-react-patterns/tree/main/src/patterns/compound-component)

## 장점 1 => API 복잡도가 낮다.

예시를 살펴보겠습니다.

```react
// 이렇게 쓰는 것보다
return (
  <Counter
    label="label"
    max={10}
    iconDecrement="minus"
    iconIncrement="plus"
    onChange={handleChangeCounter}
  />
);
// 이렇게 쓰는게 낫다!
return (
  <Counter onChange={handleChangeCounter}>
    <Counter.Decrement icon={"minus"} />
    <Counter.Label>Counter</Counter.Label>
    <Counter.Count max={10} />
    <Counter.Increment icon={"plus"} />
  </Counter>
);
```



기존에는 위의 방식처럼 부모컴포넌트에 props를 때려박고 자식 컴포넌트로 꽂아주는 방법보다는

아래의 방법처럼 각각의 props가 서브컴포넌트에 붙어있는 방법이 더 좋습니다.



## 장점 2 => 유연한 마크업 구조

![img](https://miro.medium.com/max/700/1*X2NPGy2TRJ1MsZbkR7VACA.png)

딱봐도 컴포넌트가 엄청나게 자유롭다는 것을 볼 수 있습니다.



## 장점 3 => 관심사의 분리

대부분의 로직은 Counter Component에 포함되며, Context Api를 통해 states와 이벤트 핸들러를 통해 자식 컴포넌트 간에 공유를 합니다.

![img](https://miro.medium.com/max/700/1*NxH5i3ugYXxlPR4NO9q_0Q.png)



## 단점 1 => UI 자유도가 너무 크다

자유에는 책임이 따른다. 제가 기억하고 있는 몇 안되는 명언 중 하나입니다.

이처럼 자유에는 책임이 따르는데 이는 라이브러리를 직접 만든 개발자는 문제가 아니지만

유저의 경우 어떻게 이 컴포넌트를 사용할 지 모르니 이를 조심하여야 합니다.

![img](https://miro.medium.com/max/700/1*5gRvmOA-H4DuDOIbGb25CA.png)



## 단점 2 => JSX가 너무 커집니다.

![img](https://miro.medium.com/max/700/1*Wc8urvuBB8fnQQhVMLd88w.png)

아무리 좋은 개발 방법이라 해도 너무나도 긴 코드를 보게되면 의욕이 꺽일 수 도 있습니다.

작은 컴포넌트는 문제가 되지 않지만 큰 컴포넌트의 경우 무지막지한 코드량을 보면 좌절할 수 도 있습니다.

## 이 패턴을 사용하는 라이브러리

- [React Bootstrap](https://react-bootstrap.github.io/components/dropdowns/)
- [Reach UI](https://reach.tech/accordion/)

