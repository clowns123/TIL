> 해당 글은  [5 Advanced React Patterns](https://javascript.plainenglish.io/5-advanced-react-patterns-a6b7624267a6) 을 참고했습니다.

 

우리는 개발을 하면서 컴포넌트를 어떻게 개발을 해야할지 고민에 빠지는 경우가 있습니다.

대부분 어떠한 고민이냐면

- 어떻게 하면 컴포넌트를 **재사용** 가능하게 만들 수 있을까
- 어떻게 하면 컴포넌트를 **간단하게 사용**할 수 있게 만들 수 있을까
- 어떻게 하면 컴포넌트를 **확장 가능하게** 만들 수 있을까



이에 많은 개발자들은 여러 패턴을 만들기 시작했고 해당 문서에서는 5가지의 다른 패턴을 알아보겠습니다.

5개의 패턴으로 아래의 차이점에 대해 알아볼 것 입니다.

1. Counter 예제를 통한 실제 코드
2. 패턴의 장단점
3. 두 개의 기준을 가지고 비교
   1. Inversion of Control(IoC): 컴포넌트를 사용하는 유저에게 주어지는 유연성(flexibility)와 제어(control)의 정도
   2. Implementation complexity: 유저와 개발자 모두에 대해 그 패턴을 사용하는 난이도.
4. 해당 패턴을 사용한 라이브러리





# 1. Compound Components Pattern

이 패턴은 불필요한 [prop drilling](https://slog.website/post/13) 없게 컴포넌트를 만들 수 있게 도와줍니다.

좀 더 단독적이고 관심사를 분리하고 싶으면 해당 패턴을 추천합니다.

```react
import React from "react";
import { Counter } from "./Counter";

function Usage() {
  const handleChangeCounter = (count) => {
    console.log("count", count);
  };

  return (
    <Counter onChange={handleChangeCounter}>
      <Counter.Decrement icon="minus" />
      <Counter.Label>Counter</Counter.Label>
      <Counter.Count max={10} />
      <Counter.Increment icon="plus" />
    </Counter>
  );
}

export { Usage };
```

[Github 코드](https://github.com/alexis-regnaud/advanced-react-patterns/tree/main/src/patterns/compound-component)

## 장점 1 => API 복잡도가 낮다.

예시를 살펴보겠습니다.

```react
// 이렇게 쓰는 것보다
return (
  <Counter
    label="label"
    max={10}
    iconDecrement="minus"
    iconIncrement="plus"
    onChange={handleChangeCounter}
  />
);
// 이렇게 쓰는게 낫다!
return (
  <Counter onChange={handleChangeCounter}>
    <Counter.Decrement icon={"minus"} />
    <Counter.Label>Counter</Counter.Label>
    <Counter.Count max={10} />
    <Counter.Increment icon={"plus"} />
  </Counter>
);
```



기존에는 위의 방식처럼 부모컴포넌트에 props를 때려박고 자식 컴포넌트로 꽂아주는 방법보다는

아래의 방법처럼 각각의 props가 서브컴포넌트에 붙어있는 방법이 더 좋습니다.



## 장점 2 => 유연한 마크업 구조

![img](https://miro.medium.com/max/700/1*X2NPGy2TRJ1MsZbkR7VACA.png)

딱봐도 컴포넌트가 엄청나게 자유롭다는 것을 볼 수 있습니다.



## 장점 3 => 관심사의 분리

대부분의 로직은 Counter Component에 포함되며, Context Api를 통해 states와 이벤트 핸들러를 통해 자식 컴포넌트 간에 공유를 합니다.

![img](https://miro.medium.com/max/700/1*NxH5i3ugYXxlPR4NO9q_0Q.png)



## 단점 1 => UI 자유도가 너무 크다

자유에는 책임이 따른다. 제가 기억하고 있는 몇 안되는 명언 중 하나입니다.

이처럼 자유에는 책임이 따르는데 이는 라이브러리를 직접 만든 개발자는 문제가 아니지만

유저의 경우 어떻게 이 컴포넌트를 사용할 지 모르니 이를 조심하여야 합니다.

![img](https://miro.medium.com/max/700/1*5gRvmOA-H4DuDOIbGb25CA.png)



## 단점 2 => JSX가 너무 커집니다.

![img](https://miro.medium.com/max/700/1*Wc8urvuBB8fnQQhVMLd88w.png)

아무리 좋은 개발 방법이라 해도 너무나도 긴 코드를 보게되면 의욕이 꺽일 수 도 있습니다.

작은 컴포넌트는 문제가 되지 않지만 큰 컴포넌트의 경우 무지막지한 코드량을 보면 좌절할 수 도 있습니다.

## 이 패턴을 사용하는 라이브러리

- [React Bootstrap](https://react-bootstrap.github.io/components/dropdowns/)
- [Reach UI](https://reach.tech/accordion/)



# 2. Control Props Pattern

이 패턴은 컴포넌트를 [제어 컴포넌트](https://ko.reactjs.org/docs/forms.html#controlled-components)로 바꿔준다. 외부 상태는 single source of truth, SSOT로 사용되어 유저로 하여금 커스텀 로직을 삽입할 수 있게끔 한다.

> - Controlled component란 component의 상태를 제어할 수 있는 컴포넌트를 의미한다.
> - SSOT란 단일 진실 공급원이라고도 번역되는데, 이는 모든 데이터 요소를 한 곳에서만 제어, 편집하도록 하는 것이다. 이를 지키려고 하는 상태관리 라이브러리가 리덕스다.



아래는 예제입니다.

```react
import React, { useState } from "react";
import { Counter } from "./Counter";

function Usage() {
  const [count, setCount] = useState(0);

  const handleChangeCounter = (newCount) => {
    setCount(newCount);
  };
  return (
    <Counter value={count} onChange={handleChangeCounter}>
      <Counter.Decrement icon={"minus"} />
      <Counter.Label>Counter</Counter.Label>
      <Counter.Count max={10} />
      <Counter.Increment icon={"plus"} />
    </Counter>
  );
}

export { Usage };
```

[Github 코드]( https://github.com/alexis-regnaud/advanced-react-patterns/tree/main/src/patterns/control-props)

## 장점 1 => 더 많은 통제권을 준다.

![img](https://miro.medium.com/max/700/1*8bmVDqp_KOg347dT_600Pw.png)

메인 state가 컴포넌트 바깥에 드러나있기 때문에 개발자가 직접 컴포넌트를 컨트롤 할 수 있습니다.



## 단점 1 => 사용하기 복잡합니다.

![img](https://miro.medium.com/max/700/1*_UoRzY4lRe4WtFvJl8BtTg.png)

JSX뿐만 아니라 useState, handleChange 모두 확인을 하고 작성을 해야 해당 컴포넌트를 제대로 사용할 수 있습니다.



## 이 패턴을 사용하는 라이브러리

- [Material UI](https://material-ui.com/components/rating/#rating)

# 3. Custom Hook Pattern

좀 더 IoC에 집중해보겠습니다. 메인 로직은 이제 custom hook으로 들어가고. hook은 State, Handler와 같은 내부 로직들을 포함하며 유저에게 더 많은 통제권을 줍니다.



> **IoC(제어역전)란??**
>
> 프로그래밍에서 API를 사용하는 쪽으로 특정 역할을 넘기는 패턴을 IoC라 합니다.
>
> 컴포넌트를 조합하여 만드는 것도 제어 역전의 한 형태입니다.
>
> js에서는 map, forEach, filter, reduce 등도 대표적인 예 입니다.



```react
import React from "react";
import { Counter } from "./Counter";
import { useCounter } from "./useCounter";

function Usage() {
  const { count, handleIncrement, handleDecrement } = useCounter(0);
  const MAX_COUNT = 10;

  const handleClickIncrement = () => {
    //Put your custom logic
    if (count < MAX_COUNT) {
      handleIncrement();
    }
  };

  return (
    <>
      <Counter value={count}>
        <Counter.Decrement
          icon={"minus"}
          onClick={handleDecrement}
          disabled={count === 0}
        />
        <Counter.Label>Counter</Counter.Label>
        <Counter.Count />
        <Counter.Increment
          icon={"plus"}
          onClick={handleClickIncrement}
          disabled={count === MAX_COUNT}
        />
      </Counter>
      <button onClick={handleClickIncrement} disabled={count === MAX_COUNT}>
        Custom increment btn 1
      </button>
    </>
  );
}

export { Usage };
```



## 장점 => 더더욱 많은 제어권을 줍니다.

이제 우리는 hook과 

![img](https://miro.medium.com/max/700/1*hkyJ0eb2NRhX3pUoni0o-w.png)



## 단점 => 더더욱 복잡해집니다.

![img](https://miro.medium.com/max/700/1*Sxgs_af830xmllTwgW-HKw.png)

그냥 예제 코드만 봐도 복잡하다는걸 느낄겁니다.

로직이 렌더링하는 부분과 분리되어 있으며, 유저는 둘을 이어줘야 한다. 올바르게 사용하기 위해서는 컴포넌트가 어떻게 동작하는지 알아야할 필요가 있다.

## 이 패턴을 사용하는 라이브러리

- [React table](https://react-table.tanstack.com/docs/examples/basic)
- [React hook form](https://react-hook-form.com/api/)



# 4. Props Getters Pattern

Custom hook pattern이 엄청난 통제권을 주긴 하지만, 그만큼 컴포넌트를 이용하기 어렵게 만듭니다.

Props Getters Pattern은 이런 복잡도를 감싸기 위해 시도했습니다.

native props를 노출하는 대신 props getters의 목록을 제공합니다. 이는 유저가 올바른 JSX요소에 접근할 수 있도록 의미있는 이름을 사용해야 합니다.

```react
import React from "react";
import { Counter } from "./Counter";
import { useCounter } from "./useCounter";

const MAX_COUNT = 10;

function Usage() {
  const {
    count,
    getCounterProps,
    getIncrementProps,
    getDecrementProps
  } = useCounter({
    initial: 0,
    max: MAX_COUNT
  });

  const handleBtn1Clicked = () => {
    console.log("btn 1 clicked");
  };

  return (
    <>
      <Counter {...getCounterProps()}>
        <Counter.Decrement icon={"minus"} {...getDecrementProps()} />
        <Counter.Label>Counter</Counter.Label>
        <Counter.Count />
        <Counter.Increment icon={"plus"} {...getIncrementProps()} />
      </Counter>
      <button {...getIncrementProps({ onClick: handleBtn1Clicked })}>
        Custom increment btn 1
      </button>
      <button {...getIncrementProps({ disabled: count > MAX_COUNT - 2 })}>
        Custom increment btn 2
      </button>
    </>
  );
}

export { Usage };
```

[Github 코드](https://github.com/alexis-regnaud/advanced-react-patterns/tree/main/src/patterns/props-getters)



## 장점 => 사용하기 쉽다.

아래의 예제를 보면 컴포넌트를 사용하는 쉬운 방법을 제공하면서

복잡한 비즈니스 로직은 가려져 있습니다.

올바르게 getter를 그에 맞는 JSX 요소에 사용하면 됩니다.

![img](https://miro.medium.com/max/700/1*auZca0g2eg1Cv7THl6df6g.png)

## 장점 => 유연합니다

유저는 원한다면 props를 오버로드할 수 있습니다.

![img](https://miro.medium.com/max/700/1*59EpcnFx_GkrJ3NQ-Zg3CA.png)



## 단점 => 비즈니스 로직이 가려져 있습니다.

이는 장점으로는 복잡한 로직이 가려져 있는거지만

단점으로는 추상화되어 있어 정확하게 오버라이드 할려면 getters에 제공된 props를 바뀔 때 마다 로직 변화를 알아야 합니다.

## 이 패턴을 사용하는 라이브러리

- [React table](https://react-table.tanstack.com/docs/examples/basic)
- [Downshift](https://github.com/downshift-js/downshift#usage)



# 5. State reducer pattern

IoC에 있어서는 최고의 패턴입니다. 이 패턴은 유저에게 컴포넌트를 내부적으로 제어할 수 있는 더 발전된 방법을 제시합니다.

코드는 Custom Hook Pattern과 비슷해보이지만, 더 나아가 유저가 Hook을 통해 전달된 reducer를 정의합니다. 이 reducer는 컴포넌트 내의 모든 action들을 오버로드합니다.

```react
import React from "react";
import { Counter } from "./Counter";
import { useCounter } from "./useCounter";

const MAX_COUNT = 10;
function Usage() {
  const reducer = (state, action) => {
    switch (action.type) {
      case "decrement":
        return {
          count: Math.max(0, state.count - 2) //The decrement delta was changed for 2 (Default is 1)
        };
      default:
        return useCounter.reducer(state, action);
    }
  };

  const { count, handleDecrement, handleIncrement } = useCounter(
    { initial: 0, max: 10 },
    reducer
  );

  return (
    <>
      <Counter value={count}>
        <Counter.Decrement icon={"minus"} onClick={handleDecrement} />
        <Counter.Label>Counter</Counter.Label>
        <Counter.Count />
        <Counter.Increment icon={"plus"} onClick={handleIncrement} />
      </Counter>
      <button onClick={handleIncrement} disabled={count === MAX_COUNT}>
        Custom increment btn 1
      </button>
    </>
  );
```

[Github 코드](https://github.com/alexis-regnaud/advanced-react-patterns/tree/main/src/patterns/state-reducer)

## 장점 => 더 많은 통제권을 줍니다.

엄청나게 복잡한 경우 state reducer을 사용하는 것은 유저에게 통제권을 넘겨주는 최고의 방법입니다.

모든 내부 action들은 이제 외부에서 접근 가능하며 오버라이드를 할 수 있습니다.

![img](https://miro.medium.com/max/700/1*0hLIgVUrAN1ld9Yp3DrJQw.png)



## 단점 => 최고로 복잡합니다.

이는 reducer의 액션을 사용하면 제대로 동작을 할 수 있게 짜야 하므로 개발자가 개발하기도 복잡하고

유저도 reducer를 직접 짜야하기 때문에 유저 또한 복잡해집니다.

## 이 패턴을 사용하는 라이브러리

- [Downshift](https://github.com/downshift-js/downshift#usage)





# 6 정리

지금까지 점점 어려운 순서대로 IoC를 조절하는 다양한 방법을 공부했습니다.

큰 힘에는 큰 책임이 있듯이 컴포넌트에 많은 제어권을 주면 컴포넌트를 사용하기 복잡해 집니다.

이제 우리는 적절한 방법을 찾아서 적용을 해야합니다. 

점점 더 좋은 패턴들이 나올 수도 지금까지 배운 패턴이 최고의 패턴이 될 수 있지만 계속해서 좋은 패턴을 만들 어 봅시다.

![img](https://miro.medium.com/max/700/1*LVq5PcC09q34j7FExkY5Zg.png)
