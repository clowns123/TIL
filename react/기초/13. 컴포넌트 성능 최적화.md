# 1. 느려지는 원인

컴포넌트는 다음과 같은 상황에서 리렌더링이 발생합니다.

1. 자신이 전달받은 props가 변경될 떄
2. 자신의 state가 변경될 때
3. 부모 컴포넌트가 리렌더링될 때
4. forceUpdate 함수가 실행될 때

이러한 상황들을 최대한 발생시키지 않게 해야 컴포넌트의 속도가 빨라집니다.

이에 대해 알아보겠습니다.

# 2. 메모제이션이란?

메모이제이션이란 기존의 수행한 연산의 결과값을 어딘가에 저장해두고 **동일한 입력이 들어오면** 재활용하는 프로그래밍 기법을 말합니다.

즉 메모이제이션을 적절히 사용하면 중복 연산을 피할 수 있어 메모리를 조금 더 쓰더라도 성능 최적화가 가능합니다.



## 2.1 useMemo

먼저 간단하게 문법을 알아보겠습니다.

`useMemo(() => {}, [deps])`

deps가 변경이 된다면 첫번째 함수를 실행하고 그 값을 반환하게 됩니다.



```react
import React, { useState, useCallback, useMemo } from "react";

export default function App() {
  const [ex, setEx] = useState(0);
  const [why, setWhy] = useState(0);

  // useMemo 사용하기
  useMemo(() => {console.log(ex)}, [ex]);

  // 두 개의 버튼을 설정했다. X버튼만이 ex를 변화시킨다.
  return (
    <>
      <button onClick={() => setEx((curr) => (curr + 1))}>X</button>
      <button onClick={() => setWhy((curr2) => (curr2 + 1))}>Y</button>
    </>
  );
}
```

ex값이 변경될 때만 console.log가 찍히게 됩니다.

[코드]( https://codesandbox.io/s/usememo-2tqidm?file=/src/App.js)에서 확인해봅시다.



## 2.2 useCallback

위에서는 하나의 변수를 감지하고 변경될 때 동작하는 useMemo를 확인해봤습니다.

하지만 useCallback는 메모이제이션된 **함수**를 반환합니다. 

먼저 간단하게 사용 문법과 예제를 살펴봅시다

`useCallback(() => {}, [deps])`



```react
import React, { useState, useCallback, useMemo } from "react";

export default function App() {
  const [ex, setEx] = useState(0);
  const [why, setWhy] = useState(0);

  // useCallback 이 () => {console.log(why)} 라는 함수를 반환한다.
  const useCallbackReturn = useCallback(() => {console.log(why)}, [ex]);

  // useCallback 이 담겨있는 함수를 실행
  useCallbackReturn()

  return (
    <>
      <button onClick={() => setEx((curr) => (curr + 1))}>X</button>
      <button onClick={() => setWhy((curr2) => (curr2 + 1))}>Y</button>
    </>
  );
}
```

useCallbackReturn은 어떠한 익명 함수를 반환해주고 있습니다.


위의 useCallback 은 다음의 순서로 진행될 것입니다.

1. 처음 컴포넌트가 시작될 때 실행 **() => {console.log(0)}**
2. ex 가 변할 때까지 함수는 **() => {console.log(0)}**
3. **ex 가 변한다면** 그제서야 why 의 값을 가져와서 **() => {console.log(새로운 값)}**을 출력합니다.



해당 [코드](https://codesandbox.io/s/usecallback-51nnby?file=/src/App.js:469-475)에서 확인해보면

Y버튼을 5번 눌러도 log에는 0만 뜨지만 X를 클릭하면 5가 정상적으로 뜹니다.

즉 **deps가 변해야 함수 컴포넌트와 상태값(why) 를 공유하는 것입니다!!**



따라서 useCallback 은 함수와는 상관 없는 상태값이 변할 때,

**함수 컴포넌트에서 불필요하게 함수를 업데이트 하는 것을 방지**해줍니다.





# 3. React.memo()

React는 먼저 컴포넌트를 렌더링(rendering) 한 뒤, 이전 렌더된 결과와 비교하여 DOM 업데이트를 결정한다. 만약 렌더 결과가 이전과 다르다면, React는 DOM을 업데이트를 합니다.

[코드](https://codesandbox.io/s/react-memo-0hbgm6?file=/src/OptimizeTest.js:0-922)를 살펴보겠습니다.

```react
import React, { useEffect, useState } from "react";

const TextView = ({ text }) => {
  useEffect(() => {
    console.log(`OptimizeTest Update :: Text : ${text}`);
  });
  return <div>{text} </div>;
};

const CountView = ({ count }) => {
  useEffect(() => {
    console.log(`OptimizeTest Update :: Count : ${count}`);
  });
  return <div>{count}</div>;
};

const OptimizeTest = () => {
  const [count, setCount] = useState(1);
  const [text, setText] = useState("");

  return (
    <div style={{ padding: 50 }}>
      <h1>OptimizeTest</h1>
      <div>
        <h2>count</h2>
        <CountView count={count} />
        <button onClick={() => setCount(count + 1)}>+</button>
      </div>

      <h2>text</h2>
      <TextView text={text} />
      <input value={text} onChange={(e) => setText(e.target.value)} />
    </div>
  );
};
//나는 onChange={(e)=>setText{text}}으로 했었다.
//이게아니라 onChange={(e)=>setText(e.target.value)} 이벤트가 일어나는것의 타켓의 값을 바꾸는것이기에
export default OptimizeTest;
```

해당 컴포넌트는 버튼을 클릭해서 count를 올리거나 text를 작성할 때 마다 console.log가 찍히게 됩니다.

하지만 log를 확인해보면 우리는 count만 변경이 됬는데도 text가 업데이트 됬다고 로그가 찍히게 됩니다.

변경되지 않는 컴포넌트가 계속해서 리렌더링 되므로 이는 분명 성능에 문제가 됩니다.

이를 React.memo를 사용해서 최적화를 시켜보겠습니다.



```react
import React, { useEffect, useState } from "react";

const TextView = React.memo(({ text }) => {
  useEffect(() => {
    console.log(`Optimize Update :: Text : ${text}`);
  });
  return <div>{text} </div>;
});

const CountView = React.memo(({ count }) => {
  useEffect(() => {
    console.log(`Optimize Update :: Count : ${count}`);
  });
  return <div>{count}</div>;
});

const Optimize = () => {
  const [count, setCount] = useState(1);
  const [text, setText] = useState("");

  return (
    <div style={{ padding: 50 }}>
      <h1>Optimize</h1>
      <div>
        <h2>count</h2>
        <CountView count={count} />
        <button onClick={() => setCount(count + 1)}>+</button>
      </div>

      <h2>text</h2>
      <TextView text={text} />
      <input value={text} onChange={(e) => setText(e.target.value)} />
    </div>
  );
};

export default Optimize;
```

이제는 버튼을 클릭해 카운터를 변경하면 카운터만 변경 로그만 뜨게 됩니다.
