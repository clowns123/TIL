# 1. 느려지는 원인

컴포넌트는 다음과 같은 상황에서 리렌더링이 발생합니다.

1. 자신이 전달받은 props가 변경될 떄
2. 자신의 state가 변경될 때
3. 부모 컴포넌트가 리렌더링될 때
4. forceUpdate 함수가 실행될 때

이러한 상황들을 최대한 발생시키지 않게 해야 컴포넌트의 속도가 빨라집니다.

이에 대해 알아보겠습니다.

# 2. 메모제이션이란?

메모이제이션이란 기존의 수행한 연산의 결과값을 어딘가에 저장해두고 **동일한 입력이 들어오면** 재활용하는 프로그래밍 기법을 말합니다.

즉 메모이제이션을 적절히 사용하면 중복 연산을 피할 수 있어 메모리를 조금 더 쓰더라도 성능 최적화가 가능합니다.



## 2.1 useMemo

먼저 간단하게 문법을 알아보겠습니다.

`useMemo(() => {}, [deps])`

deps가 변경이 된다면 첫번째 함수를 실행하고 그 값을 반환하게 됩니다.



```react
import React, { useState, useCallback, useMemo } from "react";

export default function App() {
  const [ex, setEx] = useState(0);
  const [why, setWhy] = useState(0);

  // useMemo 사용하기
  useMemo(() => {console.log(ex)}, [ex]);

  // 두 개의 버튼을 설정했다. X버튼만이 ex를 변화시킨다.
  return (
    <>
      <button onClick={() => setEx((curr) => (curr + 1))}>X</button>
      <button onClick={() => setWhy((curr2) => (curr2 + 1))}>Y</button>
    </>
  );
}
```

ex값이 변경될 때만 console.log가 찍히게 됩니다.

[코드]( https://codesandbox.io/s/usememo-2tqidm?file=/src/App.js)에서 확인해봅시다.



## 2.2 useCallback

위에서는 하나의 변수를 감지하고 변경될 때 동작하는 useMemo를 확인해봤습니다.

하지만 useCallback는 메모이제이션된 **함수**를 반환합니다. 

먼저 간단하게 사용 문법과 예제를 살펴봅시다

`useCallback(() => {}, [deps])`



```react
import React, { useState, useCallback, useMemo } from "react";

export default function App() {
  const [ex, setEx] = useState(0);
  const [why, setWhy] = useState(0);

  // useCallback 이 () => {console.log(why)} 라는 함수를 반환한다.
  const useCallbackReturn = useCallback(() => {console.log(why)}, [ex]);

  // useCallback 이 담겨있는 함수를 실행
  useCallbackReturn()

  return (
    <>
      <button onClick={() => setEx((curr) => (curr + 1))}>X</button>
      <button onClick={() => setWhy((curr2) => (curr2 + 1))}>Y</button>
    </>
  );
}
```

useCallbackReturn은 어떠한 익명 함수를 반환해주고 있습니다.


위의 useCallback 은 다음의 순서로 진행될 것입니다.

1. 처음 컴포넌트가 시작될 때 실행 **() => {console.log(0)}**
2. ex 가 변할 때까지 함수는 **() => {console.log(0)}**
3. **ex 가 변한다면** 그제서야 why 의 값을 가져와서 **() => {console.log(새로운 값)}**을 출력합니다.



해당 [코드](https://codesandbox.io/s/usecallback-51nnby?file=/src/App.js:469-475)에서 확인해보면

Y버튼을 5번 눌러도 log에는 0만 뜨지만 X를 클릭하면 5가 정상적으로 뜹니다.

즉 **deps가 변해야 함수 컴포넌트와 상태값(why) 를 공유하는 것입니다!!**



따라서 useCallback 은 함수와는 상관 없는 상태값이 변할 때,

**함수 컴포넌트에서 불필요하게 함수를 업데이트 하는 것을 방지**해줍니다.





# 3. React.memo()

React는 먼저 컴포넌트를 렌더링(rendering) 한 뒤, 이전 렌더된 결과와 비교하여 DOM 업데이트를 결정한다. 만약 렌더 결과가 이전과 다르다면, React는 DOM을 업데이트한다.

