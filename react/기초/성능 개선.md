# 성능 개선

> 업데이트 일자: 2022.04.14
> 
- 참고자료
    
    [Hooks API Reference - React](https://ko.reactjs.org/docs/hooks-reference.html#usememo)
    
    [React Top-Level API - React](https://reactjs.org/docs/react-api.html)
    
    [React.memo() 현명하게 사용하기](https://ui.toast.com/weekly-pick/ko_20190731)
    
    [이제는 사용해보자 useMemo & useCallback](https://leehwarang.github.io/2020/05/02/useMemo&useCallback.html)
    
    [[React] useEffect dependency array에 object와 array 넣기](https://developer-alle.tistory.com/362)
    
    [When Using useMemo is A Really Bad Idea](https://blog.bitsrc.io/when-using-usememo-is-a-really-bad-idea-a2bdeb909812)
    
    [React 렌더링 최적화 (React.memo)](https://velog.io/@alstnsrl98/React-%EB%A0%8C%EB%8D%94%EB%A7%81-%EC%B5%9C%EC%A0%81%ED%99%94-React.memo)
    
    [TIL/13. 컴포넌트 성능 최적화.md at master · clowns123/TIL](https://github.com/clowns123/TIL/blob/master/react/%EA%B8%B0%EC%B4%88/13.%20%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%20%EC%84%B1%EB%8A%A5%20%EC%B5%9C%EC%A0%81%ED%99%94.md)
    

## 💡 리렌더링이 발생하는 상황

1. 부모 컴포넌트가 리렌더링될 때
2. 자신의 state가 변경될 때
3. 전달받은 props가 변경될 때
4. forceUpdate 함수가 실행될 때

## 🤖 메모이제이션이란?

 메모이제이션이란 기존의 수행한 연산의 결과값을 어딘가에 저장해두고 **동일한 입력이 들어오면** 재활용하는 프로그래밍 기법을 말한다. 즉, 메모이제이션을 적절히 사용하면 중복 연산을 피할 수 있어 메모리를 조금 더 쓰더라도 성능 최적화가 가능하다.

## 📝 useMemo

```jsx
const memoizedValue = useMemo(() => { return returnValue }, [deps]);
```

- 메모이제이션된 **값**을 반환
- `deps`가 변경이 되면 함수 실행 후 값을 반환
- 사용 예시
    
    ```jsx
    import React, { useState, useCallback, useMemo } from "react";
    
    export default function App() {
      const [ex, setEx] = useState(0);
      const [why, setWhy] = useState(0);
    
      // useMemo 사용하기
      const memoizedEx = useMemo(() => {
    		console.log(ex);
        return ex;
    	}, [ex]);
    
      // 두 개의 버튼을 설정했다. X버튼만이 ex를 변화시킨다.
      return (
        <>
          <button onClick={() => setEx((curr) => (curr + 1))}>X</button>
          <button onClick={() => setWhy((curr2) => (curr2 + 1))}>Y</button>
        </>
      );
    }
    ```
    
    ⇒ ex값이 변경될 때만 콘솔이 찍히게 됨
    

## 🗣 useCallback

```jsx
useCallback(fn, [deps]);
```

- 메모이제이션된 **함수**를 반환
- `useMemo(() => fn, [deps])`와 같은 동작
- 사용 예시
    
    ```jsx
    import React, { useState, useCallback, useMemo } from "react";
    
    export default function App() {
      const [ex, setEx] = useState(0);
      const [why, setWhy] = useState(0);
    
      // useCallback 이 () => {console.log(why)} 라는 함수를 반환한다.
      const useCallbackReturn = useCallback(() => {console.log(why)}, [ex]);
    
      // useCallback 이 담겨있는 함수를 실행
      useCallbackReturn()
    
      return (
        <>
          <button onClick={() => setEx((curr) => (curr + 1))}>X</button>
          <button onClick={() => setWhy((curr2) => (curr2 + 1))}>Y</button>
        </>
      );
    }
    ```
    
    - `useCallback`의 진행 순서
        1. 처음 컴포넌트가 시작됐을 때
        2. `ex`가 변할 때
    
    [useCallback](https://codesandbox.io/s/usecallback-51nnby?file=/src/App.js:469-475)
    
    ▲ `Y`를 5번 눌러도 콘솔에는 0이 뜨지만, `X`를 클릭하면 5가 정상적으로 뜨는 것을 확인
    
    ⇒ 즉, `deps`가 변해야 함수 컴포넌트와 상태값을 공유하는 것
    

## ✍️ React.memo()

```jsx
React.memo(Component, callback);
```

- 이전 `props`와 현재 `props`를 얕은 비교해 같을 경우, 해당 컴포넌트 업데이트 방지
- 콜백함수에서 비교 연산이 가능
- 사용 예시
    
    ```jsx
    const Comp = (props) => {
    	return <div> { props.isAlone ? <span>혼자</span> : <span>다수</span> } </div>
    }
    
    /* 콜백함수에서 비교 연산 */
    const MemoizedComp = React.memo(Comp, (prev, next) => {
    	if (prev.isAlone === next.isAlone) return true;
     	else return false;
    });
    
    export default MemoizedComp;
    ```
    
    ⇒ 콜백함수에서 true를 리턴했을 경우, 리렌더링 방지
    

## 🤔 언제 사용해야할까?

- 참고자료
    
    [React.memo() 현명하게 사용하기](https://ui.toast.com/weekly-pick/ko_20190731)
    
    [When Using useMemo is A Really Bad Idea](https://blog.bitsrc.io/when-using-usememo-is-a-really-bad-idea-a2bdeb909812)
    

<aside>
💡 성능 개선을 목적으로 사용해야한다.

</aside>

- 이럴 때는 사용하자
    - 불필요한 재연산, 리렌더링이 자주 일어날 때
    - `React.memo`를 이용할 때 `props`로 넘겨주는 함수나 값
        - 함수는 `useCallback`, 값은 `useMemo(Object, Array 등 넘겨주는 값이 reference value일 때)`를 사용해야함
            
            → 리렌더링될 때마다 해당 함수, 값이 재선언되어 자식 컴포넌트는 `props`가 달라졌다고 인식하기 때문
            
- 이럴 때는 사용을 다시 한 번 생각해보자
    - 비싼 연산이 아닌 경우
        
        → 비싼 연산: `Data Fetching` 등
        
    - 대부분의 경우에서 원시값은 그냥 계산하는 것이 `useMemo`를 적용하는 것보다 메모리소모가 적음
    - `useState`의 초기값에는 사용하지 않아도 됨
        
        → 컴포넌트가 언마운트될 때까지 재연산하지 않기 때문
        

## ❓ 퀴즈

> 1.   `recoil/atom/userList User[]` 방식으로 사용자 정보를 다루고 있다.
> 
> 
> 2.  `isAlone` 이라는 상태 변수로 `<혼자컴포넌트/>`와 `<다수컴포넌트/>`를 분기처리하여 렌더링하고 있다.
> 
> 3.  3인 이상일때, 특정 사용자가 진입하거나 나갔을때, `<다수컴포넌트/>의 리렌더링을 막을수 있는 방법은?`
> 

```jsx
const Comp = ( props ) => {
	return <div> { props.isAlone ? <span>혼자</span> : <span>다수</span> } </div>
}
// React.memo가 Comp 컴포넌트의 이전값과 이후값을 비교해서 리렌더링 여부를 결정한다.
const MemoizedComp = React.memo(Comp);

const App = () => {
  	const userList = useRecoilValue(userListAtom);
  	  
  	// useMemo가 userList의 변화를 메모이제이션해서 isAlone에 적절한 값을 할당한다.
  	const isAlone = useMemo(() => {
    	if (userList.length === 1) return true;
      	else return false;
    }, [userList]);
    
	return (
    	<div>
        	{ userList.map(el => <Item {...el}/>) }
        	<Comp isAlone={isAlone} />
      	</div>
    )
}
```

1. `React.memo`를 이용해 `Comp` 컴포넌트의 `props`가 변경되지 않았을 때 불필요한 리렌더링 방지
2. `useMemo`를 이용해, `userList` 값이 변하지 않았을 때, `isAlone` 값의 업데이트 방지

### ✅ 더 나아가서,

<aside>
💡 `useMemo`를 사용하는것과 `useState + useEffect`는 어떤 차이가 있을까?

</aside>

- `useState + useEffect` 에서 불필요한 리렌더링 발생
- 코드의 가독성 측면에서 `useMemo` 하나로 처리하는 게 더 깔끔

예시)

```tsx
const expensiveCalculator = (x) => x + 1;
const a = 1;

// 1. useMemo Case
const someNum = useMemo(() => {
		return expensiveCalculator(a);
},[expensiveCalculator])

// 2. useState + useEffect Case
const [someNum, setSomeNum] = useState(a);

useEffect(() => {
	setSomeNum(expensiveCalculator(a));
}, [expensiveCalculator]);

console.log(someNum);
```

1. `useMemo`에서는 즉각적으로 2가 출력된다.
2. `useState + useEffect`에서는 먼저 1이 출력된 이후에 `useEffect` 콜백 함수 연산의 결과인 2가 출력된다.