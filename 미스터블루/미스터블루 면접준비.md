# 1. 입사 질문(기술 외)

## 1.1 미스터블루에 왜 지원했습니까?

저는 평소에 웹툰, 만화, 애니, 소설 등을 자주 보면서 해당 사이트를 실제로 제작하고 싶다는 생각을 많이 하였습니다. 그러던 와중에 미스터블루라는 만화, 웹툰, 소설에 손가락에 꼽는 회사의 공고를 보고 꼭 들어가고 싶은 마음에 지원을 하게 되었습니다.



## 1.2 인상깊었던 소설이나 만화

스펙트럼 분석기, 심심한 마왕님 아스란영웅전, 오늘의 낭만부, 노네임드, 네로의 실험실, 마음의 소리

# 2. 입사 질문(기술)

## 2.1 자바스크립트의 동작 원리

자바스크립트 엔진은 **힙**과 **콜 스택**으로 이루어져 있습니다. 

힙은 객체가 저장되는 메모리 공간 콜 스택은 실행 컨텍스트가 추가되고 순차적으로 실행 후 제거되는 자료구조 입니다. 자바스크립트의 동기 소스코드는 실행 컨텍스트에 푸쉬되고 팝되면서 동기로 동작하게 됩니다.

하지만 비동기 코드를 만나게 되면 Node나 브라우저가 담당하게 되는데 이때 태스크 큐와 이벤트 루프를 제공하여 비동기 코드를 처리합니다.

비동기 코드는 태스크 큐로 들어가고(프로미스는 마이크로태스크 큐로 태스크 큐보다 우선 순위가 높다.) 이벤트 루프가 콜 스택이 비어있는지 그리고 태스크 큐에 실행 컨텍스트가 있는지 확인하고 조건이 맞으면 태스크 큐에 있는 실행 컨텍스트를 콜 스택에 보내 실행하도록 합니다.

## 2.2 스코프와 스코프 체인에 대해

스코프는 유효범위로 자바스크립트는 var의 경우는 함수 레벨 스코프 let과 const는 블록 레벨 스코프를 가지고 있습니다.

스코프 체인은 찾으려는 변수 혹은 함수가 유효범위 내에 없으면 상위 스코프로 이동하여 해당 함수에서 찾습니다. 이를 반복하여 상위 스코프가 없을 경우 비로서 해당 변수나 함수가 없다고 오류를 띄웁니다.

자바스크립트는 이를 이용하여 상속을 구현합니다.

## 2.3 클로저가 무엇인가.

클로저는 함수형 프로그래밍 언어에서 사용되는 중요한 특징이다.

MDN에서는 클로저를 함수와 그 함수가 선언된 렉시컬 환경과의 조합이라고 정의한다.

좀 더 쉽게 설명하자면 자신을 포함하고 있는 외부 함수보다 중첩 함수가 더 오래 유지되는 경우 외부 함수 밖에서 중첩 함수를 호출하더라도 외부 함수의 지역 변수에 접근할 수 있는데 이러한 함수를 클로저라고 부른다.

```js
const counter = (function () {
  // 카운트 상태 변수
  let num = 0;

  // 클로저인 메서드를 갖는 객체를 반환한다.
  // 객체 리터럴은 스코프를 만들지 않는다.
  // 따라서 아래 메서드들의 상위 스코프는 즉시 실행 함수의 렉시컬 환경이다.
  return {
    // num: 0, // 프로퍼티는 public하므로 은닉되지 않는다.
    increase() {
      return ++num;
    },
    decrease() {
      return num > 0 ? --num : 0;
    }
  };
}());

console.log(counter.increase()); // 1
console.log(counter.increase()); // 2

console.log(counter.decrease()); // 1
console.log(counter.decrease()); // 0
```

위의 익명 함수 내부에 중첩 함수 increase와 decrease가 있습니다. 이떄 couter이라는 변수에 익명 함수의 리턴값 즉 중첩 함수가 포함 된 객체를 가지고 있습니다. 이를 이용하여 익명 함수의 변수 num을 참조할 수 있습니다.

클로저는 보통 상태를 안전하게 변경하고 유지하기 위해 사용됩니다. 

## 2.4 익명 함수 사용과 형태

익명 함수는 말 그대로 함수의 이름이 없는 함수를 말합니다.

보통 이름이 있는 기명 함수는 function a(){} 처럼 함수 선언문을 사용하여 표현합니다. 이때 함수 선언문을 이름을 생략할 수 없습니다.

하지만 함수를 변수에 할당하거나 화살표 함수, 즉시 실행 함수의 경우는 익명 함수를 사용합니다.

```js
const a = function (x, y) {
    return x + y;
};
const b = (x, y) => x + y;
const c = (function (x, y) {
    return x + y;
})(1, 2);

console.log(a(1, 2), b(1, 2), c); // 3, 3, 3
```



## 2.5 if와 switch 차이에 대해서

가장 큰 차이점은 비교하여 실행하는 방법이 틀립니다.

if문은 조건을 비교 후 실행할지 무시할지 정하게 됩니다. 하지만 switch문은 case문이 많아지면 점프 테이블을 만들어서 위치를 비교 후 한번에 점프합니다. 이때문에 break문을 사용하지 않으면 아래 있는 코드가 실행됩니다.

이때문에 조건의 양이 적을 경우는 if문이 조건의 양이 많을경우 switch문이 더 효율적입니다.



## 2.6  실행 컨텍스트에 대해

자바스크립트 엔진은 소스코드를 평가 후 실행을 하는데 이때 평가하는 소스의 종류는 전역 코드 함수 코드 eval(이벨)코드 모듈 코드가 있다. 자주 사용하지 않는 eval과 모듈 코드는 제외하고 살펴봅시다.

처음 자바스크립트 코드가 실행되면 전역 코드를 평가하는데 var로 선언된 변수와 함수 선언문으로 정의된 전역 함수를 실행 컨텍스트가 관리하는 전역 스코프에 등록이 됩니다. 이 평가 과정이 끝나면 순차적으로 실행합니다. 도중에 함수가 호출되면 함수 코드를 평가를 하기 시작하고 이때 실행 컨텍스트가 관리하는 지역 스코프에 등록되고 실행하게 됩니다.

즉 실행 컨텍스트는 코드가 실행되는데 필요한 스코프, 식별자, 코드 실행 순서 등을 모두 관리합니다. 좀 더 구체적으로 식별자와 스코프는 실행 컨텍스트의 렉시컬 환경으로 코드 실행 순서는 실행 컨텍스트 스택(콜 스택)으로 관리합니다.



## 2.7 렉시컬 환경

렉시컬 환경은 식별자와 스코프를 관리합니다.

렉시컬 환경은 환경 레코드와 외부 렉시컬 환경에 대한 참조로 두 개의 컴포넌트로 관리되는데 이때 전역 렉시컬 환경과 객체 렉시컬 환경은 약간 다릅니다.

전역 렉시컬 환경의 환경 레코드는 기존의 var 키워드 변수, 전역 함수와 let과 const 키워드 변수는 각각 다른 곳에 저장이 됩니다. 외부 렉시컬 환경에 대한 참조 또한 null로 스코프 체인의 종점을 의미합니다.



## 2.8 웹의 동작 원리

웹은 브라우저의 주소창에서 시작합니다. 주소창을 이용하여 도메인을 입력하면 DNS에서 해당 도메인의 ip주소를 알아온 뒤 요청을 보냅니다. 그러면 서버는 HTML, CSS, javascript, 이미지 등 렌더링에 필요한 데이터를 브라우저로 응답합니다.

그 후 HTML을 파싱하여 DOM을 생성합니다.

CSS를 파싱하여 CSSOM을 생성합니다.

DOM과 CSSOM트리가 완성되면 둘을 결합하여 렌더트리를 생성합니다.

HTML을 파싱하다가 script를 만나면 HTML 파싱을 중단하고 자바스크립트를 파싱하기 위해 자바스크립트 엔진으로 제어권을 넘겨줍니다. 그 후 자바스크립트 엔진은 자바스크립트를 생성하여 AST(추상적 구문 트리) 를 생성합니다. 이때 HTML 코드가 다 파싱 된 후 자바스크립트를 로드하기 위해서는 자바스크립트 코드를 맨 아래 쓰던가 script에 defer 어트리뷰트를 사용합니다.

만약 자바스크립트 코드에 DOM이나 CSSOM을 변경하는 DOM API가 사용되면 리플로우와 리페인트가 일어나는데 

리플로우는 레이아웃 계산을 다시하는 것, 노드의 추가 삭제 요소의 크기 위치 윈도우 리사이징 등 레이아웃에 영향을 주는 변경이 발생한 경우에 한해 실행됩니다.

리페인트는 재결합된 렌더 트리를 기반으로 다시 페인트를 하는 것을 말합니다.



## 2.9 비동기 처리 방법

자바스크립트에서 비동기 처리 방법에는 3가지 방법이 있습니다.

1. XMLHttpRequest 객체를 사용하는 방법
2. Promise를 사용하는 방법
3. async/await를 사용하는 방법이 있습니다.



## 2.10 REST API

REST는 HTTP 프로토콜을의 장점을 최대한 활용할 수 있는 아키텍처이고 이 REST의 기본 원칙을 지킨 서비스 디자인을 RESTful이라고 표현합니다. 그리고 REST 아키텍쳐를 기반으로 서비스 API를 구현한 것을 REST API라 합니다.

REST API는 자원, 행위, 표현 3가지 요소로 구성됩니다.

자원은 URI 엔드포인트로 행위는 HTTP 요청 메서드로 표현은 페이로드로 구현합니다.

REST에서 중요한 원칙 2가지는 URI는 리소스를 표현하는데 집중하고 행위에 대한 정의는 HTTP 여청 메서드를 통해 하는 것이다.

이때 URI는 동사보다는 명사를 사용하여 구현합니다.

또한 GET과 DELETE는 페이로드를 사용하지 않습니다.



## 2.11 브라우저 렌더링 과정

브라우저의 주소창에 URL을 입력하고 엔터를 누르면 DNS를 통해 IP 주소로 변환되고 이 IP 주소를 갖는 서버에 요청을 전송합니다.

요청을 전송받은 서버는 렌더링에 필요한 데이터를 브라우저로 응답을 보내고 응답을 받은 브라우저는 해당 데이터를 가지고 렌더링을 시작합니다.

먼저 렌더링 엔진은 HTML을 파싱하고 DOM트리를 만들기 시작합니다. styly태그를 만나면 HTML 파싱을 중단하고 CSS를 파싱 후 CSSOM트리를 생성합니다. 그 후 HTML이 중단된 부분부터 다시 파싱 DOM트리 생성을 시작합니다. 그리고 DOM과 CSSOM이 다 생성되면 둘을 결합하여 렌더트리를 생성합니다.

HTML을 파싱하던 도중 script 태그를 만나면 렌더링 엔진은 잠시 멈추고 자바스크립트 엔진에 제어권을 넘겨 자바스크립트를 해석 후 AST(추상적 구문 트리)를 생성합니다. 그리고 이를 기반으로 바이트코드를 생성하여 실행합니다.

자바스크립트를 실행 도중 HTML과 CSS에 영향이 가는 코드가 있으면 DOM과 CSSOM이 변경되고 다시 렌더 트리로 결합되고 화면에 렌더링 되는데 이때 리플로우->리페인팅 과정을 지나게 됩니다.

레이아웃 계산을 다시하는 노드 추가/삭제, 요소의 크기/위치 변경 등 이러한 변경이 없을 경우 리플로우를 하지 않고 리페인트만 실행하게 됩니다.

리페인트는 재결합된 렌더트리를 기반으로 다시 페인트를 하는 것을 의미합니다.

> 자바스크립트를 맨 마지막에 실행하기
>
> HTML이 끝나고 script태그 넣거나 defer이라는 어트리뷰트를 추가해준다.



## 2.12 브라우저 저장소에 대해 설명해보세요

- 쿠키 : 쿠키는 클라이언트에 키-값 형태로 데이터를 저장하는 방식입니다.

- 세션 : HTTP Session id를 식별자로 구별하여 데이터를 사용자 브라우저가 아닌 접속한 서버 DB 정보를 저장합니다.

- 웹 스토리지 : HTML5의 새로운 기능으로 클라이언트에 데이터를 저장할 수 있다. 이때 로컬 스토리지와 세션 스토리지로 나눠지는데.
  - 로컬 스토리지 : 브라우저에 반영구적으로 저장하며 브라우저를 종료해도 데이터가 유지된다.
  - 세션 스토리지 : 각 세션마다 데이터가 개별적으로 저장됨 예를 들어 브라우저의 탭마다 개별적으로 데이터가 저장되는 형식, 브라우저가 종료되면 자동으로 제거된다.



# 3. Vue 기술 면접

## 3.1 Vue의 특징

Vue는 React와 Angular보다 쉽고, 빠르며 저 둘의 장점인 단방향 데이터 흐름, 양방향 데이터 바인딩을 둘 다 가지고 있다.

## 3.2 Vue의 인스턴스에 대해

Vue는 Vue() 생성자 함수를 사용하여 인스턴스를 생성하는데 이때 옵션 객체 el, data 등이 있다.

el는 Vue의 인스턴스 렌더링이 시작되는 부분, data는 인스턴스가 사용할 데이터를 의미한다.

또한 vue의 인스턴스는 vue의 컴포넌트와 동일하다.



## 3.3 단방향 데이터 바인딩과 양방향 데이터 바인딩의 차이점

단방향 양방향은 말 그대로 데이터 흐름이 단방향이냐 양방향이냐를 의미하는데

단방향 바인딩은 데이터와 템플릿을 결합하여 화면을 생성하고 양방향은 데이터의 변화를 감지해 템플릿과 결합하여 화면을 갱신합니다.

특히 React는 단방향 하향식 데이터 바인딩을 사용하기 때문에 하위 컴포넌트가 상위 컴포넌트에 영향을 미치지 않게 하며 이러한 단방향 데이터 바인딩은 코드를 안정성 있고 디버깅이 쉽지만. 모델과 뷰를 동기화하기 위해서는 추가 작업이 필요하고 하위 컴포넌트 변경을 조건으로 상위 컴포넌트가 바뀌는 경우 추가적인 작업이 필요합니다.

