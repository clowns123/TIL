# 강사님

[이웅모 강사님](ungmo2@gmail.com) : [사이트1](https://poiemaweb.com) [사이트2](https://poiemaweb.com/fastcampus/)



# 프론트엔드 개발자가 하는 일

애플리케이션을 사용하는 사람이 애플리케이션과 소통하기 위한 창구(UI)를 사용하기 좋게 구현한다.

UI는 상태 정보를 서버 전송하기도 하고 서버의 데이터를 가져와서 UI에 표시하기도 한다.

디자이너, 백엔드 개발자와의 협업



웹 사이트 vs 웹 어플리케이션

웹 사이트의 경우는 정보전달 위주이다. 거의 정적 정보를 제공한다.

웹 어플리케이션의 경우는 정보가 CRUD가 시시각각 바뀌기 때문에 동적 정보를 제공해야한다.



즉 프론트는 DOM을 조작하는일 서버에 요청을 하고 받는 데이터를 다루는 일



# 프론트엔드 개발자 기술

- HTML: tags & attributes, Semantic web
- CSS : Layout(float, flex, grid), transition/animation, 반응형 웹, Preprocessor(sass), css 방법론, css 프레임워크
- 크로스 브라우징
- JavaScript : ES5, ES6, ES Next, DOM/Event, Ajax, 동작원리(브라우저, 자바스크립트 엔진), node.js
- HTTP
- Tools : Git, Webpack, Bable, ESLint, npm, yarm
- Library/Framework : SAP(Angular, React, Vue.js), TypeScript, jQuery, Lodash, Axios
- TDD(테스트 주도 개발) : karma / jasmine, mocha, chai
- 알고리즘 / 자료구조



# 자바스크립트

1. 태생이 웹 사이트를 보조하기 위해 만들어졌다 그래서 과도할 정도로 친절하다. 또한 자바스크립트는 암묵적으로 처리하는게 많다. 고로 코드를 읽기가 어렵다.

> JQuery는 DOM을 선택하는 방식이 다르다. 
>
> SPA, CBD가 선택하는 방식이 다르기 때문에 사용을 안하게 된다.





# 공부할 때

1. 예습을 위주로 하라
2. 러버덕 : 전날에 배운 것을 중심으로 설명하기





# 1. 프로그래밍

프로그래밍이란 컴퓨터에게 어떠한 동작을 요구하는 것이다. 즉 컴퓨터 관점에서 생각을 해야한다.



# 2.  자바스크립트란?

1995년 넷스케이프 커뮤니케이션의 웹 페이지의 보조적인 기능을 수행하기 위해 브라우저에서 동작하는 경략의 프로그래밍 언어로 브렌던 아이크가 개발했다.

하지만 IE가 등장하면서 JavaScript가 아닌 파생언어인 JScript를 사용하면서 문제가 생겼다. 이때 크로스 브라우징 이슈가 발생하였다.



## 자바스크립트 표준화

이에 대한 해결책으로 컴퓨터 시스템의 표준을 관리하는 ECMA에서 표준화를 요청하면서 ECMAScript로 명명되었다. 이떄 1999년 ECMAScript(ES3)에서 10년만에 ECMAScript(ES5)가 다시 표준화 작업이 되었다.

| 버전                  | 출시년도 | 특징                                                         |
| :-------------------- | :------- | :----------------------------------------------------------- |
| ES1                   | 1997     | 초판                                                         |
| ES2                   | 1998     | ISO/IEC 16262 국제 표준과 동일한 규격을 적용                 |
| ES3                   | 1999     | 정규 표현식, try…catch 예외 처리                             |
| ES5                   | 2009     | HTML5와 함께 출현한 표준안. JSON, strict mode, 접근자 프로퍼티, 프로퍼티 어트리뷰트 제어, 향상된 배열 조작 기능(forEach, map, filter, reduce, some, every) |
| ES6(ECMAScript 2015)  | 2015     | let, const, class, 화살표 함수, 템플릿 리터럴, 디스트럭처링 할당, 스프레드 문법, rest 파라미터, Symbol, Promise, Map/Set, iterator, for…of, generator, Proxy, module import/export |
| ES7(ECMAScript 2016)  | 2016     | 지수(**) 연산자, Array.prototype.includes, String.prototype.includes |
| ES8(ECMAScript 2017)  | 2017     | async/await, Object 정적 메소드(Object.values, Object.entries, Object.getOwnPropertyDescriptors) |
| ES9(ECMAScript 2018)  | 2018     | [Object Rest/Spread 프로퍼티](https://github.com/tc39/proposal-object-rest-spread), Promise.prototype.finally, async generator, for await…of |
| ES10(ECMAScript 2019) | 2019     | Object.fromEntries, Array.prototype.flat, Array.prototype.flatMap, optional catch binding |
| ES11(ECMAScript 2020) | 2020     | String.prototype.matchAll, BigInt, Promise.allSettled, globalThis |



## Ajax

1999년 자바스크립트를 이용하여 서버와 브라우저가 비동기적으로 데이터를 교환할 수 있는 통신 기능인 Ajax가 XMLHttpRequest이라는 이름으로 등장했다. 

처음으로 시연한 웹 어플리케이션은 구글 맵이다. 또한 느린 웹 브라우저를 대체하는 v8 자바스크립트 엔진을 보여주었다.

> 웹 애플리케이션의 이점
>
> 다운로드를 받지 않아도 되니까 패치를 실시간으로 할 수 있다. 또한 용량을 차지하지 않는다.



## node.js 

예전에는 자바스크립트를 실행할려면 브라우저에서만 사용해야 했지만 브라우저에서 독립을 하기 위해서 node.js라는 환경을 깔면 어디서든지 자바스크립트가 돌아가게 만들었다. (JVM이 생각남)

2009년 라이언 달이 발표함 구글 v8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임 환경이다.



자바스크립트는 끊임없이 성장하고 있다.

![img](https://poiemaweb.com/assets/fs-images/2-6.png)

[Stackoverflow Developer Survey Results 2019](https://insights.stackoverflow.com/survey/2019#most-popular-technologies)



## JavaScript와 ECMAScript

ECMAScript은 언어가 아닌 사양이다.

node와 브라우저 둘다 동작이 가능하다.

즉 클라이언트 사이드, 서버 사이드 자바스크립트는 다르다. ECMAScript는 코어 자바스크립트라 부른다.



## 자바스크립트 특징

컴파일은 번역, 인터프리터는 동시 통역

자바스크립트는 인터프리터 언어이지만 자바스크립트 엔진의 경우는 컴파일을 사용하기도 한다. 하지만 통상적으로 인터프리터 언어라고 한다.



자바스크립트는 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어이다. c는 명령형, 자바는 클레스 기반 객체지향이다.



# 3. 자바스크립트 개발 환경과 실행 방법

브라우저에서는 동작하는데 node에서는 동작하지 않을 수 있고 node에서는 동작하는데 브라우저에서는 동작하지 않을 수 있다.



## 웹 브라우저

학습은 크롬으로 공부한다.

자바스크립트를 공부할 때는 Console, Sources를 많이 보게 된다.

| 설명        |                                                              |
| :---------- | ------------------------------------------------------------ |
| Elements    | 로딩된 웹 페이지의 DOM과 CSS를 편집하여 렌더링된 뷰를 확인해 볼 수 있다. 단, 편집한 내용이 저장되지는 않는다. 웹 페이지가 의도된 대로 렌더링되지 않았다면 이 패널을 확인하여 유용한 힌트를 얻을 수 있다. |
| Console     | 로딩된 웹 페이지의 에러를 확인하거나 자바스크립트 소스코드에 포함시킨 console.log 메소드의 실행 결과를 확인해 볼 수 있다. |
| Sources     | 로딩된 웹 페이지의 자바스크립트 코드를 디버깅할 수 있다.     |
| Network     | 로딩된 웹 페이지에 관련한 네트워크 요청(request) 정보와 퍼포먼스를 확인할 수 있다. |
| Application | 웹 스토리지, 세션, 쿠키를 확인하고 관리할 수 있다            |



## 변수

변수는 하나의 값을 기억하기 위해서 확보한 메모리 공간을 기억하는 이름

변수의 주소가 아닌 이름으로 기억하는 이유는 다른 컴퓨터에서도 그 주소를 사용하고 있을 확률이 적다.

```javascript
var a = 10 + 20;
//var는 메모리 할당 a는 할당된 메모리를 기억하는 이름
console.log(a);
//a의 메모리의 위치를 알 수 있다.
//하지만 a에 저장된 10과 20은 저장할 수 없다
//이때 10과 20은 숫자 리터럴
//10 + 20은 표현식이라 한다.
//표현식은 a값과 동치이다.
//즉 변수는 값이 될 수 있는 표현식을 할당 할 수 있다.
```





# 숙제

ASCII 코드에 대해 알아오기

예습 : 4, 5, 6번 읽어오기







# ASCII 코드

![파일:attachment/1275273992_asciitable.gif](https://ww.namu.la/s/05acaba21abdca4ab79fdc7a1c604e2535b074bbe37a51181d89120499081e0d19000a106a7c96c99bebf82bc785f0e8ff45a98a32493cef61ba8722acef834754c446022edc3783281441d60dcd7f79d250d3d9e37d70d4b110e5f8cd39dcbb)

아스키 코드는 미국 ANSI에서 표준화한 정보교환용 7비트 부호체계이다.

000부터 127까지 총 128개의 부호가 사용된다. 영문 키보드로 입력할 수 있는 모든 기호들이 할당되어 있다.

하지만 2바이트 이상의 코드를 표현할 수 없기 때문에 한글이나 한자를 사용할려면 유니코드를 사용해야한다.

아스키 코드의 경우는 1바이트를 사용하는데 문자를 구성하는 요소가 7비트인 이유는 나머지 1비트는 Parity Bit라고 해서 1의 개수가 홀수면 1 짝수면 0으로 배치해서 통신 에러 검출을 위해 사용한다.

단 요즘은 더 이상 안쓰고 맨 앞 비트에 0을 붙이고 나머지 7비트를 쓰는 형식이다.

C언어의 경우

```c
int main(){
	printf("문자 : %c", 65)    //A
}
```

처럼 문자를 인식하지 못하기 때문에 문자를 숫자형식으로 인식하는데 쓰인다.

javascript의 경우

```javascript
console.log(
  "String.fromCharCode(65, 83, 67, 73, 73) : " +
    String.fromCharCode(65, 83, 67, 73, 73)
);	//String.fromCharCode(65, 83, 67, 73, 73) : ASCII
```







# 예습

## 1. 변수랑 무엇이고 왜 필요할까

애플리케이션은 데이터를 입력 받아서 처리하고 그 결과를 출력하는게 전부다.

변수는 데이터를 관리하기 위한 핵심 개념이다.

```javascript
10 + 20
```

위의 코드는 숫자 10과 20을 연산자 +로 합산을 하고 있다. 이때 컴퓨터의 cpu는 +연산을 수행하기 위해 양 옆의 숫자값, 피연산자를 기억해야 한다. 즉 메모리를 사용하여 데이터를 기억한다.

> 메모리는 데이터를 저장할 수 있는 메모리 셀 들의 집합체이다. 셀 하나의 크기는 1byte(8bit)이며 컴퓨터는 셀의 크기, 즉 1byte 단위로 데이터를 저장하거나 읽어 들인다.
>
> 또한 그 각 셀에는 고유의 메모리 주소를 갖고 메모리 공간의 위치를 나타낸다.



숫자 10과 20은 메모리 상 임의의 위치(메모리 주소)에 기억이 되고 cpu는 이 값을 읽어들여 연산을 수행한다. 결과값인 30도 메모리 어딘가에 저장이 된다.

하지만 우리는 해당 주소값을 알 수가 없기 때문에 결과값인 30을 읽을 수도 가져와서 사용할 수도 없다. 실제 메모리 주소를 직접 접근하는 것은 자바스크립트에서 치명적인 오류를 야기할 수 있는 문제로 허용하지 않는다. 잘못하면 OS가 사용하는 메모리 공간을 건들여서 시스템에 심각한 오류가 발생하기도 한다. 그러면 어떻게 할까?

자바스크립트에서는 변수를 사용하여 저장한 값을 기억하게 된다.

변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다.

위에서 선언한 10 + 20의 결과값을 저장하는 변수를 보자

```javascript
var result = 10 + 20;
```

10 + 20이 연산을 통해 30을 생성한다 그리고 결과값을 메모리 공간에 저장하는데 해당 메모리 공간은 result라고 var명령어를 통해 이름을 붙여준다. 변수에 값을 저장하는 것을 **할당(대입)**이라 하고 변수에 저장된 값을 읽는 것을 **참조**라고 한다.

변수의 이름을 통해 참조를 요청하면 자바스크립트 엔진은 변수 이름을 통해 변수 이름과 매핑된 메모리 주소를 통해 메모리 공간에 접근하여 저장된 값을 반환한다. 



## 식별자

변수 이름을 식별자라고도 부른다.

식별자는 어떤 값을 구별하여 식별해낼 수 있는 고유한 이름을 말한다.

위에서 살펴본 식별자 result는 30이라는 값을 직접 가지고 있는게 아닌 30이라는 값을 저장하고 있는 메모리의 주소값을 저장하고 있다.

식별자는 컴퓨터가 아닌 사람을 위해 만드는 것이므로 해당 변수가 가지고 있는 값을 한눈에 알아볼 수 있도록 만들어야 한다 이를 **네이밍 규칙**이라고 한다.



## 변수 선언

변수 선언이란 변수를 생성하는 것을 말한다. 위에서 설명했던 것 처럼 변수의 공간을 확보(할당)하고 변수 이름과 확보된 메모리 공간의 주소를 연결하여 값을 저장 할 수 있도록 마련한다.

변수 선언으로 확보된 메모리 공간은 확보를 해제하기 전까지는 누구도 그 공간을 사용할 수 없게 보호한다.

자바스크립트에서는 **var, let, const** 3가지 키워드로 변수를 할당한다.

> 키워드란 자바스크립트 엔진이 수행할 동작을 규정한 명령어이다.
>
> 키워드의 경우는 네이밍으로 사용할 수 없다.

> ES5까지는 자바스크립트에서 변수를 할당할 수 있는 키워드는 var 하나 뿐 이었다.
>
> 하지만 사용하면서 다양한 단점들이 있었고 그것들을 해결하고자 ES6에 도입된 새로운 키워드 const ,let이다.  하지만 그렇다고 ES6에서 var 키워드를 사용이 불가능한 것은 아니다.

var키워드를 사용하여 변수를 선언하면 메모리 공간을 식별자 명으로 기억한다.

해당 메모리가 할당이 되면 자바스크립트 엔진은 해당 메모리 공간을  **undefined**로 초기화 된다.

1. 선언 : 변수 이름을 등록하여 자바스크립트 엔진에 변수의 존재를 알린다.

   - ```javascript
     var score; //score라는 식별자를 등록한다.
     ```

2. 초기화 : 값을 저장하기 위해 메모리 공간을 확보하고 undefined값을 할당한다.

   - ```javascript
     score = undefined;
     ```

> 변수의 이름은 실행 컨텍스트라는 자바스크립트가 소스코드를 평가하고 실행히는데 필요한 환경을 제공하고 실행한 결과값을 보관하는 환경에서 관리한다.



일반적으로 초기화란 변수가 할당 된 후 최초로 값을 할당하는 것을 말한다.  var의 경우는 undefined로 초기화 된다.

만약 초기화 단계를 거치지 않으면 다른 어플에서 사용한 값이 남아있을 수도 있는데 그 값을 쓰레기 값이라고 한다.

변수를 사용할려면 반드시 선언이 필요하며 변수 뿐만 아니라 다른 모든 식별자들도 선언을 하고 사용해야 한다. 그렇지 않으면 ReferenceError(참조에러)가 발생한다.



## 변수 선언의 실행 시점과 변수 호이스팅

```javascript
console.log(score); //undefined
var score = 1;		
```

변수 선언문보다 변수를 참조하는 코드가 앞에 있다. 자바스크립트는 한줄한줄 실행되므로 console.log(score)가 먼저 실행이 되야하고 그러면 ReferenceError(참조에러)가 발생해야하는데 어째서일까?

그 이유는 변수 선언이 소스 코드가 실행되는 시점이 아닌 그 이전인 평가 과정이 따로 있기 때문이다.

자바스크립트 엔진은 소스코드를 평가 과정을 거치고 그 후 코드 실행을 한다. 평가 과정에서 변수 선언을 포함한 모든 선언문(변수 선언문, 함수 선언문 등)을 먼저 실행한다. 이 평가 과정이 끝나고 실행을 하기 때문에 이 증상이 발생한다.

> 이 증상의 상세한 정보는 나중에 실행 컨텍스트를 살펴볼 때 자세히 다루고 지금은 코드가 실행 전 평가 과정이 있다는 것만 알아두자

결국 모든 선언문은 먼저 실행이 되고 그 후 값이 할당되기 때문에 score를 먼저 실행해도 ReferenceError(참조에러)가 뜨지는 않지만 score에는 undefined가 들어간다.



## 값의 할당

변수에 값을 할당 할 때는 할당 연산자(=)를 사용한다. 우변에 값을 좌변의 변수에 대입한다.

```javascript
var s;	//한줄한줄 선언도 가능하고
s = 10;
var a = 20;	//단축표현도 가능하다.
```

위에서 설명한 변수 호이스팅에서도 score에 1을 할당했지만 나오지 않는 이유도 평가 과정에 변수가 할당은 되지만 값의 할당은 소스 코드가 실행될 때 값이 할당되기 때문이다.



```javascript
console.log(score); // undefined

score = 80; // 값의 할당
var score;  // 변수 선언

console.log(score); // 80
//평가 과정에서 var score는 먼저 변수 공간을 할당하고
//소스 실행에서 score에서 다시 한번 값을 할당하기 때문에 80을 출력한다.
```



## 값의 재할당

```javascript
var score = 10;
score = 20;
```

위처럼 값을 버리고 새로운 값을 할당이 가능하다.

실은 처음에 대입되는 undefined값으로 초기화 된건 다시 10으로 할당했기에 재할당으로 볼 수 있다.

변수는 재할당이 가능하기에 변수라 불린다. 만약 재할당이 불가능하면 상수라 부른다.

> const 
>
> ES6에서 새롭게 도입된 이 키워드는 선언과 동시에 값을 할당 후 재할당이 불가능하다 그렇기에 상수를 표현한다.



만약 값이 재할당 되고 그 이전의 값은 어떻게 될까?

우리는 신경쓸 필요가 없다. 자바스크립트 엔진에서 아무런 참조를 하지 않는 메모리 값을 자동으로 가비지 컬렉터가 메모리를 해제하기 때문이다. 단 언제 해제될지는 몰라서 여러 이슈들이 있다.

만약 내가 메모리의 해제 타이밍을 잡고 싶으면 C언어같이 저수준의 언어를 공부해야한다.



## 값의 교환

```javascript
var x = 1;
var y = 2;
var temp = x;
var x = y;
var y = x;
console.log(x, y)	//2, 1
```



## 식별자 네이밍 규칙

식별자는 어떤 값을 구별해낼 수 있는 이름을 말한다. 그렇기 때문에 다음과 같은 규칙을 준수하여 사람이 읽기 쉽게 만들어야 한다.

- 식별자는 특수문자를 제외한 문자, 숫자, 언더바(_), 달러 기호($)만 포함이 가능하다

- 단 특수문자를 제외한 문자, 언더바(_), 달러 기호($)로 시작해야 한다. 숫자로 시작은 허용하지 않는다.
- 예약어는 식별자로 사용이 불가능하다.

> 예약어
>
> 예약어란 프로그래밍 언어에서 사용되고 있거나 사용될 예정인 단어를 말한다.
>
> await break case catch class const continue debugger default delete do else enum export extends false finally for function if implements* import in Instanceof interface* let* new null package* private* protected* public* return super static* Switch this throw true try typeof var void while with yield* 가 있다.



- ES5부터는 유니코드 문자를 허용하므로 영어를 제외한 나머지 문자도 사용이 가능하지만 가능하면 영어로 쓰는게 좋다.
- 자바스크립트의 식별자는 대소문자를 구분한다.
- 식별자 이름은 어떤 역활을 하는지 알기 쉽게 만들어야 한다.
- 여러 단어를 조합하여 만든 식별자 명은 네이밍 컨벤션을 이용해 만든다.

```javascript
//카멜 케이스
var firstName;
//스네키으 케이스
var first_name;
//파스칼 케이스
var FirstName;
//헝가리안 케이스
var strFirstName
```

어떠한 방법을 써도 좋지만 변수나 함수의 이름은 **카멜 케이스** 생성자 함수, 클래스의 이름에는 **파스칼 케이스**를 이용하는 것이 좋다.