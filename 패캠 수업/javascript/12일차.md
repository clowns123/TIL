# 23. 실행 컨텍스트

# 1. 소스 코드 평가

소스코드 : 우리가 만든 텍스트를 의미 이것을 브라우저나 node로 실행

| 소스 코드의 타입         | 설명                                                         |
| :----------------------- | :----------------------------------------------------------- |
| 전역 코드(global code)   | 전역에 존재하는 소스 코드를 말한다. 전역에 정의된 함수, 클래스 등의 내부 코드는 포함되지 않는다. |
| 함수 코드(function code) | 함수 내부에 존재하는 소스 코드를 말한다. 함수 내부에 중첩된 함수, 클래스 등의 내부 코드는 포함되지 않는다. |
| eval 코드(eval code)     | 빌트인 전역 함수인 eval 함수에 인수로 전달되어 실행되는 소스 코드를 말한다. |
| 모듈 코드(module code)   | 모듈 내부에 존재하는 소스 코드를 말한다. 모듈 내부의 함수, 클래스 등의 내부 코드는 포함되지 않는다. |

이 4가지는 실행 컨텍스트를 만든다. if문이나 for문은 실행 컨텍스트를 만들지 않는다.

전역 코드는 let, const와 var가 다른곳에 저장이된다.

함수 코드는 매개변수, 변수, 함수, arguments 객체를 가진다.



# 2. 소스 코드의 평가와 실행

자바스크립트는 진입점이 없기 때문에 소스코드가 로드 되면 바로 실행한다. 소스 코드는 평가와 실행 2단계로 나눠서 진행한다. 

**소스 코드 평가 과정**에서는 실행 컨텍스트가 만들어진다. 평가는 식별자를 등록을 하는 작업을 한다. 변수와 함수 선언문만 먼저 실행하여 실행 컨텍스트의 렉시컬 환경의 환경 레코드에 저장한다.

**소스 코드 실행 과정**에서는 선언문을 제외한 나머지 소스코드를 실행 한다. 이때 실행 컨텍스트에서 평가과정에 등록한 식별자가 있는지 확인 후 할당을 한다. 그 후 다시 실행 컨텍스트에 저장한다.

즉 모든 소스의 결과가 실행 컨텍스트에서 관리가 된다.

`var x; x = 1;`는 평가 과정에서 실행 컨텍스트에서 x라는 키를 만들고 undefined로 초기화 한다. 그리고 실행 과정에서 x = 1을 실행한다. 이때 실행 컨텍스트에서 x라는 식별자가 있는지 확인하고 1이라는 값을 재할당한다. 이때 어떠한 실행 컨텍스트인지 알려면 **실행 컨텍스트 스택**에서 확인한다.



# 3. 실행 컨텍스트의 역할

**실행 컨텍스트는 식별자(변수, 함수, 클래스 등의 이름)를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 매커니즘으로 모든 코드는 실행 컨텍스트를 통해 실행되고 관리된다.**

식별자와 스코프는 실행 컨텍스트의 **렉시컬 환경**으로 관리하고 코드 실행 순서는 **실행 컨텍스트 스택**으로 관리한다. 먼저 실행 컨텍스트 스택에 대해 살펴보도록 하자.



# 4. 실행 컨텍스트 스택

실행 컨텍스트를 관리하는 것을 실행 컨텍스트 스택이라고 한다.



# 5. 렉시컬 환경

## 전역 렉시컬 환경

실행 컨텍스트는 **LexicalEnvironment 컴포넌트**와 **VariableEnvironment 컴포넌트**로 구성된다.

특수한 상황을 제외하고  LexicalEnvironment 컴포넌트와 VariableEnvironment 컴포넌트는 **렉시컬 환경**을 가르킨다. 이 렉시컬 환경이 스코프를 만든다.

렉시컬 환경은 **환경 레코드**와 **외부 렉시컬 환경 참조**가 있다.

환경 레코드는 **객체 환경 레코드**와 **선언적 환경 레코드**로 이루어져있고 식별자와 식별자에 할당된 값을 관리한다. 

객체 환경 레코드는 BindingObject으로 이루어져 있으며 전역 객체를 가리킨다. 이때 var와 함수 선언문은 전역 객체에 저장한다. 또한 [[GlobalThisValue]]를 가지고 있어서 this를 결정한다.

선언적 환경 레코드는 let과 const가 저장이 된다.

외부 렉시컬 환경 참조는 상위 스코프의 렉시컬 환경을 가리킨다.

## 함수 렉시컬 환경

전역 렉시컬 환경의 환경 레코드는 객체 환경 레코드와 선언적 환경 레코드로 이루어져 있지만 함수 환경 레코드는 **함수 환경 레코드** 1개 뿐이다. 이때도 함수 환경 레코드가 [[ThisValue]]가 this를 가리킨다.

외부 렉시컬 환경은 해당 함수가 만들어진 장소를 가리킨다. [[Environment]]이라는 내부 슬롯이 정보를 담고 있다.



## if문과 for문과 같이 블록 레벨 스코프의 경우

if문의 블록 스코프에 들어가면 새로운 if 렉시컬 환경을 만들게 된다. 이때 실행 컨텍스트도 임시적으로 해당 if 렉시컬 환경을 가리키고 if 렉시컬 환경의 외부 렉시컬 환경의 참조는 바꾸기 이전으로 바꾼다.

for문도 마찬가지로 for 렉시컬 환경을 만들고 바꾸지만 반복할 때 마다 추가로 만들어준다.



# 24. 클로저

클로저는 자바스크립트의 고유의 개념이 아니라 함수형 언어의 특성이다. 그렇기 때문에 ECMAScript에는 정의되어 있지 않다. MDN에서는 다음과 같이 정의되어 있다.

> “A closure is the combination of a function and the lexical environment within which that function was declared.”
>
> 클로저는 함수와 그 함수가 선언된 렉시컬 환경(lexical environment)과의 조합이다.
>
> 즉 함수와 상위 스코프의 조합이다.

**함수는 자신의 내부 슬롯 [[Environment]]에 자신이 정의된 환경, 즉 상위 스코프의 참조를 저장한다.** 즉 렉시컬 스코프는 [[Environment]]로 구현한다.

외부 함수보다 내부 함수가 더 오래 살아있으면 내부 함수의 [[Environment]]가 외부 함수의 렉시컬 환경을 참조하고 있기 때문에 사라지지 않는다. 이 현상을 클로저라 한다.

이때 내부 함수에서 외부 함수를 참조할 일이 없을경우 클로저라 하지 않고 기억하지도 않는다.

즉 클로저는 2가지 조건을 만족해야 한다.

1. 외부 함수보다 중첩함수가 더 오래 생존해야 한다.
2. 중첩 함수가 외부함수의 식별자를 참조해야한다.

하지만 원칙적으로 따지면 모든 함수는 클로저지만 최적화를 한 것이다.



## 클로저의 활용

**클로저는 상태를 안전하게 유지하기 위해 사용한다.** 

공식처럼 외우자

---

즉시 실행 함수를 만든다. -> 즉시 실행 함수 안에 유지하고 싶은 변수를 선언한다. -> 변수를 변경하는 함수를 만들고 return하라

---





# 예습 범위

26 : 클래스 1~7번은 잘 봐두고 8번 이후는 설렁설렁 보자

DOM을 사용할 때 클래스를 사용하면 문제가 생긴다.

27 : 화살표 								함수, Rest를 꼼꼼히 보자