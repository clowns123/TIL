# 예습

# 14. 전역 변수의 문제점

전역 변수의 무분벼한 사용은 위험하다. 전역 변수를 반드시 사용하여야 할 이유를 찾지 못한다면 지역 변수를 사용하여야 한다. 전역 변수의 문제점과 전역 변수의 사용을 억제할 수 있는 방법에 대해 살펴보도록 하자.



## 1. 변수의 생명 주기

**1. 지역 변수의 생명 주기**

변수는 선언에 의해 생성되고 할당을 통해 값을 갖는다. 그리고 언젠가 소멸한다. 이것을 변수의 생명 주기라 한다.

그렇다면 변수는 언제 생성이 되고 언제 소멸이 될까?

```javascript
function foo(){
    var x = 'local';
    console.log(x);
    return x;
}
foo();			// x, return x
console.log(x)	// x is not defined
```

foo함수에서는 사용할 수 있던 x는 함수가 사라지고 나서는 사용이 불가능하다. 고로 변수 x는 foo가 생성될 때 생성이 되고 foo함수가 사라지면 사용이 불가능하다.  즉, **지역 변수의 생명 주기는 함수의 생명 주기와 일치한다.**



```javascript
var x = 'global';

function foo() {
  console.log(x);	//undefined
  var x = 'local';
  return x;
}

foo();
console.log(x); // global
```

이때 변수의 생성 시기도 잘 알아야 하는데 함수가 실행되면 먼저 함수 본체의 코드를 평가를 한다. 그때 var로 생성된 변수는 호이스팅이 발생해서 undefined로 초기화 되므로 foo()안에서의 log(x)는 undefined가 출력이 된다.



**2. 전역 변수의 생명 주기**

지역 변수의 경우는 함수가 시작되면 생성되고 함수가 끝나면 사라지지만 전역 변수는 프로그램이 시작하면 생성되고 끝나면 사라진다. 즉 프로그램 시작부터 끝까지 메모리에 상주한다는 뜻이다.  var 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 된다. 이는 전역 변수의 생명 주기가 전역 객체의 생명 주기와 일치한다는 것을 말한다.

> **전역 객체**
>
> 전역 객체는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체이다.  전역 객체는 브라우저에서는 window, Node.js에서는 global 객체를 의미한다.



## 2. 전역 변수의 문제점

**1. 암묵적 결함**

전역 변수를 선언한 의도는 전역, 즉 코드 어디에서든지 전역 변수를 사용하겠다는 것이다. 이는 모든 코드가 전역 변수를 참조하고 변경할 수 있는 암묵적 결합을 허용하는 것이다. 변수의 유효 범위가 커지면 코드의 가독성이 나빠지고 의도치 않게 상태가 변경될 수 있는 위험이 있다.



**2. 긴 생명 주기**

전역 변수는 생명주기가 길다. 그렇기 때문에 메모리 리소스도 오래 차지한다. 



**3. 스코프 체인 상에서 종점에 존재**

이는 변수를 검색할 때 전역 변수가 가장 마지막에 검색이 된다. 즉 전역 변수의 검색 속도는 가장 느리다.



**4. 네임 스페이스 오염**

자바스크립트의 큰 문제점 중 하나는가장 큰 문제점 중 하나는 파일이 분리되어 있다해도 전역 스코프를 공유한다. 즉 다른 파일에서 같은 이름의 변수나 함수가 같은 스코프에 있으면 예상치 못한 일이 일어난다.



## 3. 전역 변수 사용 억제 방법

전역 변수의 무분별 사용은 위와 같은 문제점을 야기하기 때문에 전역 변수를 사용할 이유가 없다면 지역 변수를 사용해야 한다. **변수의 스코프는 좁으면 좁을수록 좋다.**



**1. 즉시 실행 함수**

함수 정의와 동시에 호출되는 즉시 실행 함수는 단 한번만 호출된다.  **모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 된다.** 

```javascript
(function () {
  var foo = 10; // 즉시 실행 함수의 지역 변수
  // ...
}());

console.log(foo); // ReferenceError: foo is not defined
```



**2. 네임 스페이스 객체**

전역에 네임 스페이스 역할을 담당할 객체를 생성하고 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가한다.

```javascript
var MYAPP = {}; // 전역 네임 스페이스 객체
MYAPP.name = 'Lee';
console.log(MYAPP.name); // Lee

MYAPP.person = {
  name: 'Lee',
  address: 'Seoul'
};
console.log(MYAPP.person.name); // Lee
```

식별자 충돌 방지효과는 있지만 네임 스페이스 객체 자체가 전역 변수에 할당되므로 유용하지는 않다.



**3, 모듈 패턴**

모듈 패턴은 클래스를 모방하여 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만든다. 모듈 패턴은 자바스크립트의 강력한 기능인 클로저를 기반으로 동작한다. 이로 인해 전역 변수 억제 이외에 캡슐화 까지 구형이 가능하다.

> **캡슐화**
>
> 외부에 공개될 필요 없는 정보를 외부에 노출시키지 않고 숨기는 것을 말한다. 정보은닉이라고도 한다.
>
> Java의 경우 private, public, protected 등의 접근 제한자를 사용해 공개 범위를 정한다.

```javascript
var Counter = (function () {
  // private 변수
  var num = 0;

  // 외부로 공개할 데이터나 메소드를 프로퍼티로 추가한 객체를 반환한다.
  return {
    increase() {
      return ++num;
    },
    decrease() {
      return --num;
    }
  };
}());

// private 변수는 외부로 노출되지 않는다.
console.log(Counter.num); // undefined

console.log(Counter.increase()); // 1
console.log(Counter.increase()); // 2
console.log(Counter.decrease()); // 1
console.log(Counter.decrease()); // 0
```



**4. ES6 모듈**

```javascript
<script type="module" src="lib.mjs"></script>
<script type="module" src="app.mjs"></script>
```

위의 코드를 사용하여 로드된 자바스크립트 파일은 모듈로 동작한다.

하지만 구형 브라우저는 동작하지 않으므로  Babel, Webpack을 이용하여 모듈링 하는 방법이 있다.



# 15. let과 const와 블록 레벨 스코프

ES6이전에는 var만으로 변수를 생성할 수 있었다. 하지만 많은 단점이 있다.

## 1. var 키워드로 선언한 변수의 분제

**1. 변수의 중복 선언 허용**

var 키워드로 선언한 변수는 중복 선언이 가능하다.

```javascript
var x = 1;
var y = 1;

// var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용한다.
// 초기화문이 있는 변수 선언문은 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작한다.
var x = 100;
// 초기화문이 없는 변수 선언문은 무시된다.
var y;

console.log(x); // 100
console.log(y); // 1
```



위에서 x와 y가 중복되어 선언되었다. 이때 x는 덮어 쓰지만 y는 초기화문이 없어서 무시되었다. 이렇게 의도치 않게 변경되는 경우가 있다.



**2. 함수 레벨 스코프**

var 키워드로 선언한 변수는 오로지 함수의 코드 블록만 지역 스코프로 인정한다.

```javascript
var x = 1;
var i = 10;

if (true) {
  // x는 전역 변수이다. 이미 선언된 전역 변수 x가 있으므로 변수 x는 중복 선언된다.
  // 이는 의도치 않게 변수값이 변경되는 부작용을 발생시킨다.
  var x = 10;
}

// for문에서 선언한 i는 전역 변수이다. 이미 선언된 전역 변수 i가 있으므로 중복 선언된다.
for (var i = 0; i < 5; i++) {
  console.log(i); // 0 1 2 3 4
}
//의도치 않게 i와 x의 값이 바꿨다.
console.log(i); // 5
console.log(x); // 10
```



**3. 변수 호이스팅**

var 키워드로 변수를 선언하면 변수 호이스팅이 발생한다. 할당 전에 변수를 참조하면 undefined를 반환한다.



## 2. let 키워드

앞에서 살펴본 var 키워드의 단점을 보완하기 위해 ES6에서는 새로운 변수 선언 키워드 let과 const를 도입하였다.



**1. 변수 중복 선언 금지**

var 키워드는 중복을 하여도 에러가 발생하지 않는다. 하지만 let은 중복 선언하면 에러를 발생시킨다.

```javascript
let bar = 123;
// let이나 const 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용하지 않는다.
let bar = 456; // SyntaxError: Identifier 'bar' has already been declared
```



**2. 블록 레벨 스코프**

var와 다르게 모든 코드 블록을 지역 스코프로 인정한다.

```javascript
{
    let a = 1;
    var b = 2;
}
console.log(a);	//1
console.log(b);	//참조 에러
```



**3. 변수 호이스팅**

var 키워드와 달리 let은 변수 호이스팅이 발생하지 않는 것처럼 동작한다.

```javascript
console.log(a); //참조 에러
let a = 1;
```

var로 선언된 변수는 선언 단계에서 스코프(실행 컨텍스트의 렉시컬 환경)에 변수 식별자를 등록하여 자바스크립트 엔진에 변수 존재를 알리고 바로 초기화 작업으로 undefined를 초기화 하는데

let 키워드로 선언된 변수는 선언 단계와 초기화 단계가 분리되어 진행된다. 즉 자바스크립트 엔진에 의해 암묵적으로 선언 단계가 먼저 실행되지만 초기화 단계는 변수 선언문에 도달했을 때 실행된다.

즉 초기화 단계 이전에 변수에 접근할려면 참조 에러가 발생한다. let 키워드로 선언한 변수는 스코프의 시작 지점부터 초기화 단계 시작 지점까지 변수를 참조할 수 없다. 이를 일시적 사각지대라 부른다. 하지만 변수 호이스팅이 발생하지 않는건 아니다.

```javascript
let foo = 1; // 전역 변수

{
  console.log(foo); // ReferenceError: Cannot access 'foo' before initialization
  let foo = 2; // 지역 변수
}
```

위 코드에서 코드 블록 안에있는 log의 경우 다른 언어라면 전역 변수를 출력하겠지만 변수 호이스팅이 발생하는 자바스크립트는 지역변수 let foo가 호이스팅이 발생해서 오류가 발생하게 된다. 이처럼 동작하지 않는 것 처럼 보이는 거지 동작하지 않는 것은 아니다.





**4. 전역 객체와 let**

전역 객체는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체이며 어떤 객체에도 속하지 않은 최상위 객체이다. 전역 객체는 클라이언트 사이드 환경(브라우저)에서는 window, 서버 사이드 환경(Node.js)에서는 global 객체를 가리킨다.

var 키워드로 선언한 전역 변수와 전역 함수 그리고 선언하지 않은 변수에 값을 할당한 암묵적 전역은 전역 객체의 프로퍼티가 된다. 전역 객체의 프로퍼티를 참조할 때 window를 생략할 수 있다.

```javascript
// 이 예제는 브라우저 환경에서 실행시켜야 한다.

// 전역 변수
var x = 1;
let z = 2;
// 암묵적 전역
y = 2;
// 전역 함수
function foo() {}

// var 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티이다.
console.log(window.x); // 1
// 전역 객체의 프로퍼티는 전역 변수처럼 사용할 수 있다.
console.log(x); // 1

// 암묵적 전역은 전역 객체의 프로퍼티이다.
console.log(window.y); // 2
console.log(y); // 2

// 함수 선언문으로 정의한 전역 함수는 전역 객체의 프로퍼티이다.
console.log(window.foo); // ƒ foo() {}
// 전역 객체의 프로퍼티는 전역 변수처럼 사용할 수 있다.
console.log(foo); // ƒ foo() {}

// let, const 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다.
console.log(window.x); // undefined
console.log(x); // 1
```





## 3. const 키워드

const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화가 이뤄져야 한다. 그리고 const 키워드로 선언한 식별자는 재할당이 불가능하다. 즉 const 는 상수를 반드는 키워드이다.

**const 키워드와 객체**

const키워드로 선언한 원시값은 변경이 불가능하다. 하지만 const 키워드로 선언한 변수에 객체를 할당할 경우 객체의 프로퍼티는 바꿀 수 있다.

const 는 재할당이 불가능한거지 값 변경이 불가능한 것이 아니다.





## 4. 결론

- ES6를 사용한다면 var 키워드는 사용하지 않는다.
- 기본적으로 원시값은 const로 선언한다.
- 재할당이 필요한 경우에 한정해 let 키워드를 사용한다. 이때 변수의 스코프는 최대한 좁게 만든다.
- 변경이 발생하지 않고 읽기 전용으로 사용하는(재할당이 필요 없는 상) 원시 값과 객체에는 const 키워드를 사용한다. const 키워드는 재할당을 금지하므로 var, let 키워드보다 안전하다.









# 복습

# 12. 함수

함수란 입력, 처리, 출력으로 이루어져 있다.

함수의 사용 이유는 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높이는 효과가 있고 코드의 가독성을 높힌다.

**함수를 만드는 방법은 총 4가지가 있다.**

- 함수 선언문
- 함수 표현식
- function 생성자 함수(안씀)
- 화살표 함수(ES6)

여기서 함수 선언문과 함수 표현식을 보겠다. function 생성자 함수는 사용하지 않고 화살표 함수는 중요하기 떄문에 따로 공부한다.



```javascript
// 함수 선언문
function add(x, y) {
  return x + y;
}
// 함수 표현식
var add = function add(x, y) {
  return x + y;
};
```

이때 함수 선언문은 표현식이 아닌 문이고 함수 표현식은 표현식인 문이다. 

함수 선언문은 암묵적으로 함수 이름과 같은 변수에 할당이 된다. 또한 함수 호이스팅이 발생해 함수를 선언 전 사용이 가능하다.

함수 표현식은 함수 호이스팅이 아닌 변수 호이스팅이 발생해 함수를 선언 전 사용이 불가능하다.



함수의 경우는 인수를 매개변수로 받는데 인수가 많이 들어오면 다음에 들어오는 것을 무시하지만 부족할 경우는 문제가 생긴다.

매개 변수란 변수처럼 함수가 실행될때 생성이 되며 undefined로 초기화 되고 인수를 받아서 재할당을 하는데 부족할 경우 undefined가 계산을 방해할 수 있기 때문에 초기화 작업이 필요하고. 또한 매개변수의 타입을 확인하지 않기 때문에 확인하는 작업이 필요하다.



```javascript
function add(x = 0, y = 0) { //ES6 이후 초기화 
  x = a || 0;	//ES6 이전 초기화
  y = b || 0;
  return a + b + c;
  if (typeof x !== 'number' || typeof y !== 'number') {
    // 매개변수를 통해 전달된 인수의 타입이 부적절한 경우, 에러를 발생시킨다.
    throw new TypeError('인수는 모두 숫자값이어야 합니다.');	//에러를 발생시킨다.
  }

  return x + y;
}
```





## 함수의 다양한 형태

**1. 즉시 실행 함수**

함수 정의와 동시에 즉시 호출되는 함수를 즉시 실행 함수라 한다. 즉시 실행 함수는 단 한번만 호출되며 다시 호출할 수는 없다.

```javascript
// 익명 즉시 실행 함수
(function (a, b) {
  var a = a;
  var b = b;
  return a * b;
}(3, 5));
```





**2. 재귀 함수**

```javascript
// 팩토리얼(계승)은 1부터 자신까지의 모든 양의 정수의 곱이다.
// n! = 1 * 2 * ... * (n-1) * n
function factorial(n) {
  // 탈출 조건: n이 1 이하일 때 재귀 호출을 멈춘다.
  if (n <= 1) return 1;
  // 재귀 호출
  return n * factorial(n - 1);
}

console.log(factorial(0)); // 0! = 1
console.log(factorial(1)); // 1! = 1
console.log(factorial(2)); // 2! = 2 * 1 = 2
console.log(factorial(3)); // 3! = 3 * 2 * 1 = 6
console.log(factorial(4)); // 4! = 4 * 3 * 1 * 1 = 24
console.log(factorial(5)); // 5! = 5 * 4 * 3 * 2 * 1 = 120
```

재귀 함수는 자기 자신을 호출하는 함수이다. 기억이 안나면 팩토리얼 함수를 생각하자



**3. 중첩 함수**

```javascript
function outer() {
  var x = 1;
  // 중첩 함수
  function inner() {
    var y = 2;
    // 외부 함수의 변수를 참조할 수 있다.
    console.log(x + y); // 3
  }
  inner();
}
outer();
```

함수 내부에 정의 된 함수를 중첩 함수, 함수 외부에 정의 된 함수를 외부 함수라 하고 중첩 함수는 헬퍼 함수의 역할을 한다.



**4. 콜백 함수**

함수를 매개변수로 보낼때 인수로 보내는 함수를 콜백 함수라 한다. 콜백 함수를 받아서 처리하는 함수를 고차 함수라 한다.

```javascript
// 외부에서 전달받은 f를 n만큼 반복 호출한다
function repeat(n, f) {
  for (var i = 0; i < n; i++) {
    // i를 전달하면서 f를 호출
    f(i);
  }
}

var logAll = function (i) {
  console.log(i);
};

var logOdds = function (i) {
  if (i % 2) console.log(i);
};

// 반복 호출할 함수를 인수로 전달한다.
repeat(5, logAll); // 0 1 2 3 4

// 반복 호출할 함수를 인수로 전달한다.
repeat(5, logOdds); // 1 3
```



콜백 함수는 함수형 프로그래밍 패러다임과 비동기 처리를 위해 사용하는 중요한 패턴이다.

```javascript
// 콜백 함수를 사용한 이벤트 처리
// myButton 버튼을 클릭하면 콜백 함수를 실행한다.
document.getElementById('myButton').addEventListener('click', function () {
  console.log('button clicked!');
});

// 콜백 함수를 사용한 비동기 처리
// 1초 후에 메시지를 출력한다.
setTimeout(function () {
  console.log('1초 경과');
}, 1000);
```



배열 고차함수

```javascript
// 콜백 함수를 사용하는 고차 함수 map
var res = [1, 2, 3].map(function (item) {
  return item * 2;
});

console.log(res); // [2, 4, 6]

// 콜백 함수를 사용하는 고차 함수 filter
res = [1, 2, 3].filter(function (item) {
  return item % 2;
});

console.log(res); // [1, 3]

// 콜백 함수를 사용하는 고차 함수 reduce
res = [1, 2, 3].reduce(function (acc, cur) {
  return acc + cur;
}, 0);

console.log(res); // 6
```





**5. 순수 함수와 비순수 함수**

함수형 프로그래밍에서는 어떤 외부 상태에 의존하지도 않고 변경시키지도 않는, 즉 부수 효과가 없는 함수를 순수 함수(pure function), 외부 상태를 변경시키는 즉, 부수 효과가 있는 함수를 비순수 함수(impure function)라고 부른다.

순수 함수는 동일한 인수가 전달되면 언제나 동일한 값을 반환하는 함수를 말한다. 즉, 순수 함수는 어떤 외부 상태에도 의존하지 않고 오직 매개변수를 통해 함수 내부로 전달된 인수에게만 의존하여 반환값을 만든다. 함수의 외부 상태에 의존하는 함수는 외부 상태에 따라 반환값이 달라진다. 순수 함수의 또 하나의 특징은 함수의 외부 상태를 변경하지 않는다는 것이다.

```javascript
var count = 0;

// 함수의 외부 상태에 의존하여 외부 상태에 따라 반환값이 달라지는 비순수 함수
// 비순수 함수는 외부 상태를 변경하는 부수 효과(side effect)가 있다.
function increase() {
  return ++count; // 외부 상태를 변경한다.
}

// 비순수 함수는 외부 상태(count)를 변경하므로 상태 변화를 추적하기 어려워진다.
increase();
console.log(count); // 1

increase();
console.log(count); // 2


// 외부 상태에 의존하지 않으며 변경하지도 않는 순수 함수
// 순수 함수는 동일한 인수가 전달되면 언제나 동일한 값을 반환한다.
function increase1(n) {
  return ++n;
}

// 순수 함수가 반환한 결과값을 변수에 재할당하여 상태를 변경
//count의 변수가 비순수 함수로 오염되었다.
count = increase1(count);
console.log(count); // 3

count = increase1(count);
console.log(count); // 4
```





## 13. 스코프

스코프란 식별자를 검색할 때 사용하는 규칙이다. 보통 전역 스코프와 지역 스코프가 있다.보통 스코프는 코드 블록을 통해서 구분한다.

지역 변수는 해당 코드 블록의 하위 스코프에서만 사용이 가능하다. 하지만 전역 변수는 모든 스코프에서 사용이 가능하다.

 **모든 식별자(변수 이름, 함수 이름, 클래스 이름 등)는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다. 이를 스코프(Scope, 유효범위)라 한다. 즉, 스코프는 식별자가 유효한 범위를 말한다.**



> **var 키워드로 선언한 변수의 중복 선언**
>
> var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언이 허용된다. 이는 의도치 않게 변수값이 재할당되어 변경되는 부작용을 발생 또한 var는 함수 블록만을 지역 스코프로 인정하기 때문이다.
>
> 하지만 let이나 const 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용하지 않고 모든 코드 블록을 지역 스코프로 인정한다.



**스코프는 함수의 중첩에 의해 계층적 구조를 갖는다 이를 스코프 체인이라고 부른다.**

**변수를 참조할 때, 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다.**

자바스크립트 엔진은 스코프 체인을 따라 변수를 참조하는 코드의 스코프에서 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다. 절대 하위 스코프로 내려가면 식별자를 검색하는 일은 없다. 이는 **상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있지만 하위 스코프에서 유효한 변수를 상위 스코프에서 참조할 수 없다**는 것을 의미한다.



##  렉시컬 스코프

프로그래밍 언어는 2가지 방법 중 하나로 스코프를 결정한다.

1. **함수를 어디서 호출**했는지에 따라 함수의 상위 스코프를 결정한다.
2. **함수를 어디서 정의**했는지에 따라 함수의 상위 스코프를 결정한다.

이중 자바스크립트는 2번으로  **함수를 어디서 호출했는지가 아니라 함수를 어디서 정의했는지에 따라 상위 스코프를 결정한다.**