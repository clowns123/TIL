# 24 프로미스

> **비동기 동작 방식**
>
> 이벤트 루프는 무한루프를 돌면서 콜스택을 확인한다. 만약 콜스택이 비어있으면 태스크 큐에 넣어논 비동기 함수를 콜스택으로 가져와 실행한다.
>
> 비동기 함수는 실행되면 바로 콜스택으로 가서 실행하는게 아닌 태스크 큐에 일시 저장이 된다.  



프로미스는 내부 상태를 가지고 있고 실시간으로 변하게 된다.



Promise는 모든 비동기 행위때 다 사용이 가능하다.

이때 Promise를 실행할려면 then, catch, finally가 있다. then은 성공 실패 2가지 형태를 받을 수 있지만 일반적으로는 then은 성공 catch는 실패를 써준다. finally은 무조건 실행한다.

then은 Promise 객체를 리턴하기 때문에 then을 연달아 쓰는 체이닝 작업이 가능하다.

then메소드는 가급적 한줄 씩 사용하는게 좋다. 만약 then안에 한번에 사용한다면 가독성이 좋지 않다.

비동기처리에서는 애러처리에 한계가 있기 때문에 try catch문을 잘 사용하지 않는다.

---



> 예전에는 에러를 로그파일에 저장했지만 요즘은 외부 서비스를 사용을한다. 그러면 해당 서비스 센서 db에 저장이 되고 분석도 해주므로 편하다.



> ORM
>
> RDB와 우리가 사용하는 자바스크립트의 데이터 타입이 다르기 때문에 중간에 ORM을 두어서 데이터 타입을 바꿔준다.



> RESPAPI
>
> GET, PATCH, POST, DELETE, PUT을 확실하게 알자
>
> ex) GET /todos/1 : todos의 1번을 주세요 
>
> 즉 네이밍을 잘하자 
>
> 백엔드와 프론트의 통신을 잘 하기 위한 컨셉





---

# 46 이터레이터

# 1. 이터러블/이터레이터 프로토콜

- 이터러블 : 이터레이터를 리턴하는 &#91;Symbol.iterator&#93;&#40; &#41;를 가진 값
- 이터레이터 : { value, done } 객체를 리턴하는 next() 를 가진 값
- 이터러블/이터레이터 프로토콜 : 이터러블ㅇ을 for...of, 전개 연산자 등과 함께 동작하도록한 규약



# 2. 이터러블 구현

```js
// 이터레이션 프로토콜을 구현하여 무한 이터러블을 생성하는 함수
const userIterable = function () {
  let i = 5; // 자유 변수
  return {
    [Symbol.iterator]() { return this; },
    next() {
      return  i === 0 ? {done : true} : { value: --i , done:false};
    }
  };
};
```

