# 13. 스코프

스코프는 식별자와 함수와 관련이 있다.

우리는 이전에 함수에서 경험해보았다. 함수 이름은 함수 내부에서만 사용할 수 있다.

변수는 자기가 선언된 위치에 따라서 스코프가 결정된다. 함수 내부는 지역 변수 외부는 전역변수 이다.

var의 경우는 함수만을 스코프로 인정하지만 let나 const는 모든 코드 블록을 스코프로 인정한다.

스코프는 서로 연관 관계를 가진다. 이를 스코프 체인이라고 부른다. 

변수를 생성할 때 자바스크립트의 엔진에게 해당 식별자를 등록한다. **실행 컨텍스트(렉시컬 컴포넌트의 환경 컴포넌트)**에 저장을 한다.  이를 이용해 스코프 체인을 구현한다. 스코프 체인은 단방향 링크드 리스트이다.

함수는 호출된 위치보다 정의된 위치가 중요하다.

함수와 변수는 스코프 체인에서 찾고 객체에 있는 프로퍼티는 프로토타입 체인에서 찾는다.

관리는 객체 형식으로 관리된다.

함수 스코프는 자바스크립트의 단점이다.

```javascript
var i = 10;
for(var i = 0; i < 5; i++){
    console.log(i); // 0, 1, 2, 3, 4
}

console.log(i)	//원하는 건 10인데 for문에 i가 전역이라 4가 나온다.
```



## 렉시컬 스코프

```javascript
var x = 1;
function foo(){	// 상위 스코프는 전역이다.
    var x = 10;
    bar();
}
function bar(){	// 상위 스코프는 전역이다.
    console.log(x);	// 해당 스코프에 x가 없기에 상위 스코프로 가서 x를 찾는다.
}
foo();	// 1
bar();	// 1
// 위의 설명을 클로저이다.
```





# 14. 전역 변수의 문제점

1. 생명 주기가 길다.

생성은 식별자가 메모리를 먹을때 사망은 가비지 컬렉터가 메모리를 헤제할때이다. 지역 변수의 경우는 함수가 실행될 때 생성되고 return이 되면 죽는다. 하지만 전역 변수는 프로그램이 실행 될때 생성되고 프로그램이 종료되면 사망한다.

> **진입점**
>
> 다른 언어의 경우는 main이라는 진입점이 있다. 즉 전역 변수라고 해도 main이 시작이 되고 난 후에 시작이 된다. 하지만 자바스크립트는 진입점이 없기 때문에 HTML에 의해 로드되면 바로 실행이 된다.

2. 암묵적 결합(최고 문제)

전역 코드는 모든 코드가 참조할 수 있고 변경이 많이 된다. 즉 전역 변수가 에러발생의 원인이 된다.

3. 긴 생명 주기

전역 변수의 생명 주기가 길기 때문에 메모리 낭비가 심하다.

4. 스코프 체인 상 종점에 존재

전역 변수의 검색 속도가 가장 느리다.

5. 네임 스페이스 오염

변수의 식별자를 만들때 신경을 많이 써야 한다. 아니면 전역 변수가 오염된다.



## 전역 변수 사용 억제

1. 즉시 실행 함수로 만든다.
2. 네임 스페이스 객체로 만든다. 단 예전 방식이라 잘 안쓴다.
3. 모듈 패턴

```javascript
var Counter = (function () {
  // private 변수
  var num = 0;

  // 외부로 공개할 데이터나 메소드를 프로퍼티로 추가한 객체를 반환한다.
  return {
    increase() {
      return ++num;
    },
    decrease() {
      return --num;
    }
  };
}());

// private 변수는 외부로 노출되지 않는다.
console.log(Counter.num); // undefined

console.log(Counter.increase()); // 1
console.log(Counter.increase()); // 2
console.log(Counter.decrease()); // 1
console.log(Counter.decrease()); // 0
```

4. ES6 모듈

하지만 완벽하진 않다.





# 15. let, const와 블록 레벨 스코프

## 1. var 키워드의 문제점

1. 변수 중복 선언 허용
2. 함수 레벨 스코프
3. 변수 호이스팅

## 2. let 키워드

1. 변수 중복 선언 금지
2. 블록 레벨 스코프
3. 변수 호이스팅을 하면 오류 발생

안하는 것처럼 오류가 뜨지만 발생은 한다.

```javascript
let foo = 1; // 전역 변수

{
  console.log(foo); // ReferenceError: Cannot access 'foo' before initialization 원래 foo가 없으면 상위 스코프에서 foo를 찾아야 하는데 참조 에러가 뜬다. 이 부위를 일시적 사각지대(TDZ)라 부른다.
  let foo = 2; // 지역 변수
}
```

4. 전역 객체와 let

브라우저 환경에서는 window, Node.js환경 에서는 global객체를 가진다.

이때 var로 생성한 변수는 window, global의 전역 객체에 프로퍼티가 된다. 하지만 let은 안된다.

```javascript
var a = 1;	// undefined
let b = 2;	// undefined
window.a;	// 1
window.b;	// undefined
```



## 3. const 키워드

const 키워드로 선언한 식별자는 선언과 동시에 할당을 해줘야 한다. 그 이후에는 재할당이 불가능하다. 단 주의할 점은 재할당이 불가능하므로 객체의 프로퍼티를 바꾸는건 된다.

상수로 만들때는 키워드를 대문자로 쓴다(컨벤션)

1. 선언과 초기화
2. 재할당 금지
3. 상수
4. const 키워드와 객체

## 4. var vs let vs const

실무에서는 객체를 많이 사용하기에 const로 선언을 한 후 재할당이 필요하면 let으로 바꾼다.



>  React/Angular은 식별자가 바뀐지 안바뀐지 감시한다. 이때 주소를 재할당을 하면 바뀐다는 걸 알기에 객체도 재할당을 할 수 있다.



# 자료 구조와 알고리즘

