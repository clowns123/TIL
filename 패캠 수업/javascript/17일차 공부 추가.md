# 6. 이벤트 전파

DOM 트리 상에 존재하는 DOM 요소 노드에서 발생한 이벤트는 DOM 트리를 통해 전파된다. 이를 이벤트 전파라고 한다.

```html
<!DOCTYPE html>
<html>
    <body>
        <ul id="fruits">
            <li id="apple">Apple</li>
            <li id="banana">Banana</li>
            <li id="orange">Orange</li>
        </ul>
    </body>
</html>
```

![image-20200526094414028](https://user-images.githubusercontent.com/50760015/82849997-82841a00-9f35-11ea-90ba-845ec0526839.png)

- 캡처링 단계(capturing phase) : 이벤트가 상위 요소에서 하위 요소 방향으로 전파
- 타깃 단계(target phase) : 이벤트가 이벤트 타깃에 도달
- 버블링 단계(bubbling phase) : 이벤트가 하위 요소에서 상위 요소 방향으로 전파

이처럼 DOM 트리를 통해 전파되는 이벤트는 이벤트를 발생시킨 이벤트 타깃은 물론 상위 DOM 요소에서도 캐치할 수 있다. 예를 들어, 위 예제의 ul 요소에 이벤트 핸들러를 바인딩하면 자신이 발생시킨 이벤트 뿐만 아니라 하위 요소에서 발생한 이벤트까지 캐치할 수 있다. 하위 요소에서 발생한 이벤트는 버블링되기 때문이다.

이벤트 핸들러는 기본적으로 타깃 단계와 버블링 단계의 이벤트를 캐치한다.

```html
<!DOCTYPE html>
<html>
<body>
  <ul id="fruits">
    <li id="apple">Apple</li>
    <li id="banana">Banana</li>
    <li id="orange">Orange</li>
  </ul>
  <script>
    const $ul = document.querySelector('ul');

    // $ul 요소에 바인딩된 이벤트 핸들러는 버블링 단계의 이벤트를 캐치한다.
    // 따라서 이벤트 핸들러는 $ul 요소와 $ul 요소의 하위 요소에서 발생하여
    // 버블링되는 이벤트를 모두 캐치할 수 있다.
    $ul.onclick = e => {
      console.log(`이벤트 단계: ${e.eventPhase}`);
      console.log(`이벤트 타깃: ${e.target.nodeName}#${e.target.id}`);
    };
  </script>
</body>
</html>
```

위 예제는 ul에 이벤트를 주었지만 li를 찍고 올라가면서  ul의 이벤트를 캐치하기 때문에 이벤트를 주지 않은 li에도 이벤트가 발생하게 된다.



이벤트 핸들러 어트리뷰트/프로퍼티 방식으로 등록한 이벤트 핸들러는 타깃 단계와 버블링 단계의 이벤트만을 캐치할 수 있다. 하지만 addEventListener 메소드 방식으로 등록한 이벤트 핸들러는 버블링 또는 캡처링 단계의 이벤트를 선별적으로 캐치할 수 있다. 캡처링 단계의 이벤트를 캐치하려면 addEventListener 메소드의 3번째 인수로 true를 전달해야 한다. 3번째 인수를 생략하거나 false를 전달하면 타깃 단계와 버블링 단계의 이벤트만을 캐치할 수 있다.

```html
<!DOCTYPE html>
<html>
<body>
  <ul id="fruits">
    <li id="apple">Apple</li>
    <li id="banana">Banana</li>
    <li id="orange">Orange</li>
  </ul>
  <script>
    const $ul = document.querySelector('ul');

    // 이벤트를 캡처링 단계에서 캐치한다.
    // $ul 요소보다 상위 요소에서 발생한 이벤트는 캐치할 수 없다.
    $ul.addEventListener('click', e => {
      console.log(`이벤트 타깃: ${e.target.id}`);
    }, true);
  </script>
</body>
</html>
```

버블링 단계 또는 캡처링 단계의 모든 이벤트는 이벤트 패스(이벤트가 통과하는 DOM 트리 상의 경로)에 위치한 모든 DOM 요소에서 캐치할 수 있다. 참고로 이벤트 패스는 Event.prototype.composedPath 메소드로 확인할 수 있다.

아래 예제를 살펴보자. 다음은 캡처링 단계의 이벤트와 버블링 단계의 이벤트를 캐치하는 이벤트 핸들러가 혼용되는 경우이다.

```html
<!DOCTYPE html>
<html>
<head>
  <style>
    html, body { height: 100%; }
  </style>
<body>
  <p>버블링과 캡처링 이벤트 <button>버튼</button></p>
  <script>
    // 버블링 단계의 이벤트를 캐치
    document.body.addEventListener('click', () => {
      console.log('Handler for body.');
    });

    // 캡처링 단계의 이벤트를 캐치
    document.querySelector('p').addEventListener('click', () => {
      console.log('Handler for paragraph.');
    }, true);

    // 버블링 단계의 이벤트를 캐치
    document.querySelector('button').addEventListener('click', () => {
      console.log('Handler for button.');
    });
  </script>
</body>
</html>
```



버튼을 클릭하면

```js
// Handler for paragraph.
// Handler for button.
// Handler for body.
```



P 태그를 클릭하면

```js
// Handler for paragraph.
// Handler for body.
```



# 7. 이벤트 위임

해당 이벤트 전파를 통해서 이벤트 위임을 구현할 수 있다.

이벤트 위임(Event delegation)은 다수의 하위 요소에 각각 이벤트 핸들러를 등록하는 대신 하나의 상위 요소에 이벤트 핸들러를 등록하는 방법을 말한다. 하위 요소에서 발생한 이벤트는 버블링 단계(bubbling phase)에서 부모 요소 방향으로 전파된다. 따라서 상위 요소는 하위 요소에서 발생한 이벤트를 캐치할 수 있다. 이벤트 위임을 통해 상위 DOM 요소에 이벤트 핸들러를 등록하면 여러 개의 하위 요소에 이벤트 핸들러를 등록할 필요가 없다. 또한 동적으로 하위 요소를 추가하더라도 일일이 추가된 요소에 이벤트 핸들러를 등록할 필요가 없다.

```html
<!DOCTYPE html>
<html>
<head>
  <style>
    #fruits {
      display: flex;
      list-style-type: none;
      padding: 0;
    }

    #fruits li {
      width: 100px;
      cursor: pointer;
    }

    #fruits .active {
      color: red;
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <nav>
    <ul id="fruits">
      <li id="apple" class="active">Apple</li>
      <li id="banana">Banana</li>
      <li id="orange">Orange</li>
    </ul>
  </nav>
  <div>선택된 네비게이션 아이템: <em class="msg">apple</em></div>
  <script>
    const $fruits = document.getElementById('fruits');
    const $msg = document.querySelector('.msg');

    // 사용자 클릭에 의해 선택된 네비게이션 아이템(li 요소)에 active 클래스를 추가하고
    // 그 외의 모든 네비게이션 아이템의 active 클래스를 제거한다.
    function activate({ target }) {
      // 이벤트를 발생시킨 요소(target)이 ul#fruits의 자식 요소가 아니라면 무시한다.
      if (!target.matches('#fruits > li')) return;

      [...$fruits.children].forEach($fruit => {
        // if ($fruit === target) target.classList.add('active');
        // else $fruit.classList.remove('active');
        $fruit.classList.toggle('active', $fruit === target);
        $msg.textContent = target.id;
      });
    }

    // 이벤트 위임: 상위 요소(ul#fruits)는 하위 요소의 이벤트를 캐치할 수 있다.
    $fruits.onclick = activate;
  </script>
</body>
</html>
```



# 8. 기본 동작의 변경

## 8.1. 기본 동작 중단

DOM 요소의 저마다의 기본 동작이 있다. 예를 들어, a 요소를 클릭하면 href 어트리뷰트에 지정된 링크로 이동하고, checkbox 또는 radio 요소를 클릭하면 체크 또는 해제된다.

이벤트 객체의 preventDefault 메소드는 이러한 DOM 요소의 기본 동작을 중단시킨다.

```html
<!DOCTYPE html>
<html>
<body>
  <a href="https://www.google.com">go</a>
  <input type="checkbox">
  <script>
  document.querySelector('a').onclick = e => {
    // a 요소의 기본 동작을 중단한다.
    e.preventDefault();
  };

  document.querySelector('input[type=checkbox]').onclick = e => {
    // checkbox 요소의 기본 동작을 중단한다.
    e.preventDefault();
  };
  </script>
</body>
</html>
```



## 8.2. 이벤트 전파 방지

이벤트 객체의 stopPropagation 메소드는 이벤트 전파를 중지시킨다. 아래 예제를 살펴보자.

```html
<!DOCTYPE html>
<html>
<body>
  <div class="container">
    <button class="btn1">Button 1</button>
    <button class="btn2">Button 2</button>
    <button class="btn3">Button 3</button>
  </div>
  <script>
    document.querySelector('.container').onclick = ({ target }) => {
      if (!target.matches('.container > button')) return;
      target.style.color = 'red';
    };

    // btn2 요소는 이벤트를 전파하지 않으므로 상위 요소에서 이벤트를 캐치할 수 없다.
    document.querySelector('.btn2').onclick = e => {
      // 이벤트 전파 중단
      e.stopPropagation();
      e.target.style.color = 'blue';
    };
  </script>
</body>
</html>
```

위 예제를 살펴보면 상위 요소인 container 요소에 이벤트를 위임하였다. 따라서 하위 요소에서 발생한 클릭 이벤트를 상위 요소인 container 요소가 캐치하여 이벤트를 처리한다. 하지만 하위 요소 중에서 btn2 요소는 자체적으로 이벤트를 처리한다. 이때 btn2 요소는 자신이 발생시킨 이벤트가 전파되는 것을 중단하여 자신에게 바인딩된 이벤트 핸들러만 실행되도록 한다.

이처럼 상위 요소와 하위 요소의 이벤트를 각각 별도로 처리하기 위해 이벤트의 전파를 중단시키기 위해서 stopPropagation 메소드를 사용한다.





# 9. 이벤트 핸들러 내부의 this

## 9.1. 이벤트 핸들러 어트리뷰트 방식

이벤트 핸들러 어트리뷰트 방식의 경우, 이벤트 핸들러 내부의 this는 전역 객체 window를 가리킨다.

```html
<!DOCTYPE html>
<html>
<body>
  <button onclick="handleClick()">Click me</button>
  <script>
    function handleClick () {
      console.log(this); // window
    }
  </script>
</body>
</html>
```



## 9.2. 이벤트 핸들러 프로퍼티 방식과 addEventListener 메소드 방식

이벤트 핸들러 프로퍼티 방식과 addEventListener 메소드 방식 모두 이벤트 핸들러 내부의 this는 이벤트를 바인딩한 DOM 요소를 가리킨다. 즉, 이벤트 객체의 currentTarget 프로퍼티와 같다.

```html
<!DOCTYPE html>
<html>
<body>
  <button class="btn1">0</button>
  <button class="btn2">0</button>
  <script>
    const $button1 = document.querySelector('.btn1');
    const $button2 = document.querySelector('.btn2');

    // 이벤트 핸들러 프로퍼티 방식
    $button1.onclick = function (e) {
      // this는 이벤트를 바인딩한 DOM 요소를 가리킨다.
      console.log(this); // <button id="btn">Click me</button>
      console.log(e.currentTarget); // <button id="btn">Click me</button>
      console.log(this === e.currentTarget); // true

      // $button의 textContent를 1 증가시킨다.
      ++this.textContent;
    };

    // addEventListener 메소드 방식
    $button2.addEventListener('click', function (e) {
      // this는 이벤트를 바인딩한 DOM 요소를 가리킨다.
      console.log(this); // <button id="btn">Click me</button>
      console.log(e.currentTarget); // <button id="btn">Click me</button>
      console.log(this === e.currentTarget); // true

      // $button의 textContent를 1 증가시킨다.
      ++this.textContent;
    });
  </script>
</body>
</html>
```