# 예습(11장)

# 11. 원시 값과 객체의 비교

## 원시 값

1. 변경 불가능한 값

원시 타입의 값은 변경 불가능한 값이다. 다시 말해 한번 생성된 원시 값은 read only한 값이므로 변경할 수 없다. 이를 **불변성**이라고 한다.

이를 착각하지 말아야 하는게 변수가 변경이 불가능하다는게 아닌 **확보한 메모리의 값이 변경이 불가능하다는 것이다.** 이를 상수 const와 비교하면 안된다.

변수의 원시 값을 변경할 때는 메모리에 있는 값을 변경하는게 아닌 새로운 메모리에 값을 넣고 변수는 메모리 주소만 바꾼다. 



2. 문자열과 불변성

원시 값인 문자열은 다른 값과 비교해서 독특한 특징이 있는데 문자열은 0개 이상의 문자로 이루어진 집합을 의미하며 1개의 문자는 2byte의 메모리 공간에 저장된다. 이는 문자의 개수가 늘어날 수록 필요한 메모리 공간이 늘어나는 것을 의미한다.

다른 언어의 경우를 살펴보면 c언어에서는 문자열이라는 데이터 타입이 없고 문자 타입인 char을 배열로 묶은 것을 문자열로 사용한다. Java의 경우는 문자열을 String 객체로 처리한다.

하지만 자바스크립트는 개발자의 편의를 위해 원시 타입인 문자열 타입을 제공한다.

```javascript
var str = 'Hello';
str = 'World';
```

위의 코드를 보면 처음 자바스크립트는 Hello라는 문자열을 메모리에 저장하고  그 후 새롭게 World라는 문자열을 메모리에 저장하고 변수가 해달 메모리 주소를 가지게 된다. 이를 유사 배열 객체라 한다.

> 유사 배열 객체는 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체를 말한다. 문자열은 마치 배열처럼 인덱스를 통해 각 문자에 접근할 수 있으며 length 프로퍼티를 갖기 때문에 유사 배열 객체이고 for 문으로 순회할 수도 있다.하지만 인덱스로 접근하여 해당 값을 바꿀 수는 없다
>
> ```javascript
> var str = "string";
> str[0] = "A"
> console.log(str)	//str
> ```



3. 값에 의한 전달

```javascript
var s = 80;
var c = s;
console.log(s); //80
console.log(c); //80

s = 100;

console.log(s);	//100
console.log(c);	//80
```

c에 할당한 s는 s의 주소값을 참조하는게 아닌 메모리를 새롭게 할당 후 s의 값을 복사해서 메모리에 저장하고 새롭게 할당한 메모리의 주소를 가지게 된다. 그렇기 때문에 s와 c는 별개의 존재이다.

이를 **값에 의한 전달**이라 한다.

하지만 값에 의한 전달이라 해도 착각하면 안되는 것은 자바스크립트의 식별자는 값이 저장된 메모리의 주소값을 가지고 있기 때문에 엄밀히 따지면 아니다. 이 개념에서 중요한 것은 **결국은 두 변수의 원시값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어 어느 한쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭할 수 없다**는 것이다.



## 객체

객체는 프로퍼티의 개수가 정해져 있지 않으며 동적으로 추가되고 삭제할 수 있다. 또한 프로퍼티의 값에도 제약이 없다. 따라서 객체는 원시 값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없다.



1. 변경 가능한 값

객체 타입의 값, 즉 객체는 변경 가능한 값이다.

```javascript
var person = {
    name: 'Lee'
};
```

원시 값을 할당한 변수는 원시값 자체를 값으로 갖지만 객체를 할당한 변수의 메모리는 객체를 저장하고 있는 다른 메모리 주소를 저장한다.  즉 위에 선언한 person은 객체를 저장하고 있는 다른 메모리 주소를 가지고 있다. 이로 인해 객체는 재할당없이 객체를 직접 변경할 수 있다

> **얕은 복사 깊은 복사**
>
> 객체를 프로퍼티 값으로 갖는 객체의 경우, 얕은 복사는 한 단계까지 복사하는 것을 말하고 깊은 복사는 객체에 중첩되어 있는 객체까지 모두 복사하는 것을 말한다.
>
> 얕은 복사와 깊은 복사로 생성된 객체는 원본과는 다른 객체이다. 즉, 원본과 복사본은 참조값이 다른 별개의 객체이다. 하지만 얕은 복사는 객체에 중첩되어 있는 객체의 경우, 참조값을 복사하고 깊은 복사는 객체에 중첩되어 있는 객체까지 모두 복사하여 원시 값처럼 완전한 복사본을 만든다는 차이가 있다.



객체를 생성하고 관리하는 방식은 복잡하며 비용이 많이 든다.  그렇기 때문에 원시 값처럼 메모리를 다시 할당하여 신뢰성과 명확성을 확보할수 없다.  원시 값의 방식을 사용하면 메모리 효율과 퍼포먼스가 나빠진다.

따라서 메모리를 효율적으로 사용하기 위해 그리고 객체의 복사하고 생성하는 비용을 절약하여 퍼포먼스를 향상하기 위해 객체는 변경 가능한 값으로 디자인 되어 있다.

이때 구조적 단점에 따른 부작용이 있는데 원시 값과는 다르게 **여러 개의 식별자가 하나의 객체를 공유**할 수 있다.



2. 참조에 의한 전달

여러 개의 식별자가 하나의 객체를 공유할 수 있다는 것을 알아보자

```javascript
var person = {
    name:'Lee'
};
var copy = person;

copy.name = 'kim';
person.address = 'Seoul';

console.log(copy);		//{name: 'Kim', address: "seoul"}
console.log(person);	//{name: 'Kim', address: "seoul"}
```

위 코드를 보면 복사한 객체를 수정을 하면 원본 객체에도 영향이 가는걸 볼 수 있다.

이는 객체를 할당 할때 복사본을 주는게 아닌 실제 객체의 위치를 가진 주소값을 알려주기 때문이다. 이로 인해 복사본도 원본 객체에 접근할 수 있고 변경을 할 수 있다. 하지만 C와 같이 포인터를 사용할 수 없기 때문에 참조에 의한 전달과는 정확히 일치하지 않는다.





# 복습

# 8. 제어문

## 1. 블록문

블록문은 중괄호를 사용하여 코드를 묶은 것을 의미한다. 이때 다른 언어의 경우에는 코드 블록 밖에서 코드 블록 안에 있는 변수를 사용이 불가능하지만 자바스크립트의 var는 사용이 가능하다. 이는 나중에 스코프에서 확인하고 이를 해결하기 위해 let, const를 ES6에서 추가하였다.

## 2. 조건문

조건문은 2가지가 있는데 if...else, switch문이 있다.



1. if...else

if문은 조건식으로 판별하며 여러 조건식을 이어서 사용할수 있다.

```javascript
if(조건식 1){
    //코드
}else (조건식 2){
    //코드
}else{
    //위의 조건식이 모두 false일때 실행
}
```

 하지만 간단한 if문일 경우는 상항 연산자를 이용하여 해결하는게 가독성이 더 좋다.



2. switch

하나의 값을 확인하는 조건이 많을 경우 사용한다.

```javascript
switch (표현식) {
  case 표현식1:
    switch 문의 표현식과 표현식1이 일치하면 실행될 문;
    break;
  case 표현식2:
    switch 문의 표현식과 표현식2가 일치하면 실행될 문;
    break;
  default:
    switch 문의 표현식과 일치하는 표현식을 갖는 case 문이 없을 때 실행될 문;
}
```

하지만 대부분은 if...else문으로 해결이 가능하므로 꼭 사용해야하는지 다시 한번 생각하고 만들자



## 반복문

반복문은 3가지로 for, while, do...while문으로 이루어진다.

> **반복문을 대체할 수 있는 기능**
>
> forEach문, for...in, for...of문등 다양한 기능들이 있다.





1. for 문

```javascript
for (변수 선언문 또는 할당문; 조건식; 증감식) {
  조건식이 참인 경우 반복 실행될 문;
}
```

보통 반복할 횟수가 정해졌을 때 사용한다.



2. while문

```javascript
var count = 0;

while (count < 3) {
  console.log(count); // 0 1 2
  count++;
}
```

for문과 달라보이지만  count가 변수 선언문, count < 3이 조건식, count++이 증감식으로 동작은 비슷하게 하지만 while문은 반복할 횟수가 정해지지 않을때 사용한다.



3. do...while문

```javascript
var count = 0;

// count가 3보다 작을 때까지 코드 블록을 계속 반복 실행한다.
do {
  console.log(count);
  count++;
} while (count < 3); // 0 1 2
```

while문과 같지만 먼저 한번 실행 후 조건식으로 반복할지 여부를 판별한다.





4. break문

레이블 문, 반복문(for, for…in, for…of, while, do…while) 또는 switch 문의 코드 블록을 탈출한다. 이외의 블록문안에 break문을 사용하며 문법 에러이다.



5. continue문

continue 문은 반복문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 이동한다. break 문처럼 반복문을 탈출하지는 않는다.





# 9. 타입 변환과 단축평가

타입 변환은 명시적 타입 변환과 묵시적 타입 변환 2가지가 있다.



## 암묵적 타입 변환

**문자 타입**의 경우는 문자열과 다른 피연산자를 +로 연결하면 다른 피연산자를 문자열로 바꾸고 +를 문자 연결 연산자로 바꾼다.



**숫자 타입**의 경우  단항으로 피연산자 앞에 +을 붙이거나 이항으로 산술 연산자를 붙이면 숫자타입으로 변환하여 계산한다.



**불리언 타입**의 경우는 if(...)안에 쓰면 자동으로 불리안값으로 바꾼다. 이때 false, undefined, null, 0, -0, NaN, ''의 경우는 false값으로 평가되고 나머지는 true로 평가된다. {}의 경우도 true니 주의



## 명시적 타입 변환

문자 타입으로 변환은 총 3가지 방법이 있다.

1. String 생성자 함수를 new 연산자 없이 호출
2. Object.prototype.toString 메서드를 사용하는 방법
3. 문자열 연결 연산자를 이용하는 방법(**추천 방법**)



숫자 타입으로 변환은 총 4가지 있다.

1. Number 생성자 함수를 new 연산자 없이 호출하는 방법
2. parseInt, parseFloat 함수를 사용하는 방법(문자열만 숫자 타입으로 변환 가능)
3. \+ 단항 산술 연산자를 이용하는 방법(**추천 방법**)
4. \* 산술 연산자를 이용하는 방법



불리언 타입으로 변환은 총 2가지 있다.

1. Boolean 생성자 함수를 new 연산자 없이 호출하는 방법
2. ! 부정 논리 연산자를 두번 사용하는 방법(**추천 방법**)



##  단축 평가

## 

```javascript
'cat' && 'dog'	//dog
'cat' || 'dog'	//cat
```

논리합 논리곱은 결과값을 불리안값으로 변환시키지 않는다.

논리합과 논리곱은 평가가 가능하면 바로 해당 피연산자를 리턴한다.


